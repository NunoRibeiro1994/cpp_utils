#ifndef PSEUDO_ITERATOR_HPP
#define PSEUDO_ITERATOR_HPP
#include <iterator>
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Provides a pseudo-iterator class for generic storage container classes, requiring:
// 1) size_t size() [for runtime assertions]
// 2) operator[](int) [for data retrieval]
// 3) contiguous data storage on _container_type class
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
namespace std {
namespace storage {
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename _CT>
class st_pseudo_iterator {
	_CT* container; // requires size() for runtime size assertion, operator[](int) for value access
	int pos; 
public:
	st_pseudo_iterator(_CT* _d, int _p): container(_d),pos(_p) { assert(_p >= 0 && _p <= container->size()); };
	void operator++() { pos++; };
	auto operator*() -> decltype((*container)[pos]) { return (*container)[pos]; }; //C++11
	// auto& operator*()  { return (*container)[pos]; }; //C++14
	bool operator==(st_pseudo_iterator _rhs) {return pos == _rhs.pos;};
	bool operator!=(st_pseudo_iterator _rhs) {return pos != _rhs.pos;};
    // cast operator to vecto iterator
    // operator vector<_CT>
};
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
} //storage
} //std
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#endif