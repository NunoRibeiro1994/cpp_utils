<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>storage: /home/joao/Shared/PHD/code/ros/src/storage/include/storage/indexer.hpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src=""/></td>
  <td id="projectalign">
   <div id="projectname">storage<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">C++ header-only library providing generic extensions to STL containers.</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('indexer_8hpp.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">indexer.hpp File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Header file providing declaration &amp; definition of std::indexer&lt;&gt; class template, as well as specializations std::index&lt;&gt; and std::series&lt;&gt;.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;vector&gt;</code><br />
<code>#include &lt;type_traits&gt;</code><br />
<code>#include &lt;cassert&gt;</code><br />
<code>#include &lt;utility&gt;</code><br />
<code>#include &lt;exception&gt;</code><br />
<code>#include &lt;initializer_list&gt;</code><br />
<code>#include &lt;algorithm&gt;</code><br />
<code>#include &quot;type_check.hpp&quot;</code><br />
<code>#include &quot;<a class="el" href="tagged_8hpp_source.html">tagged.hpp</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="cast__iterator_8hpp_source.html">cast_iterator.hpp</a>&quot;</code><br />
<code>#include &quot;range_iterator.hpp&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for indexer.hpp:</div>
<div class="dyncontent">
<div class="center"><img src="indexer_8hpp__incl.png" border="0" usemap="#a_2home_2joao_2_shared_2_p_h_d_2code_2ros_2src_2storage_2include_2storage_2indexer_8hpp" alt=""/></div>
<map name="a_2home_2joao_2_shared_2_p_h_d_2code_2ros_2src_2storage_2include_2storage_2indexer_8hpp" id="a_2home_2joao_2_shared_2_p_h_d_2code_2ros_2src_2storage_2include_2storage_2indexer_8hpp">
<area shape="rect" title="Header file providing declaration &amp; definition of std::indexer&lt;&gt; class template, as well as specializ..." alt="" coords="381,5,560,53"/>
<area shape="rect" title=" " alt="" coords="5,101,61,125"/>
<area shape="rect" title=" " alt="" coords="451,173,530,197"/>
<area shape="rect" title=" " alt="" coords="71,173,134,197"/>
<area shape="rect" title=" " alt="" coords="758,173,810,197"/>
<area shape="rect" title=" " alt="" coords="325,101,400,125"/>
<area shape="rect" title=" " alt="" coords="424,101,517,125"/>
<area shape="rect" title=" " alt="" coords="541,101,616,125"/>
<area shape="rect" href="type__check_8hpp_source.html" title=" " alt="" coords="640,101,747,125"/>
<area shape="rect" href="tagged_8hpp.html" title="Header file providing declaration &amp; definition of std::tagged&lt;&gt; class template." alt="" coords="821,101,907,125"/>
<area shape="rect" href="cast__iterator_8hpp.html" title="Header file providing declaration &amp; definition of std::cast_iterator&lt;&gt; class template." alt="" coords="137,101,250,125"/>
<area shape="rect" title=" " alt="" coords="931,101,1053,125"/>
<area shape="rect" title=" " alt="" coords="835,173,888,197"/>
<area shape="rect" title=" " alt="" coords="912,173,979,197"/>
<area shape="rect" title=" " alt="" coords="1003,173,1074,197"/>
<area shape="rect" title=" " alt="" coords="162,173,225,197"/>
</map>
</div>
</div>
<p><a href="indexer_8hpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstd_1_1indexer.html">std::indexer&lt; Container, T, Locked &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple extensible generic container adapter that provides high-level indexing/key functionality to <em>Container</em>, while maintaining a customizable public interface of a container of <em>T</em>, in line with STL's <em>SequenceContainer</em> named requirements. Represents a pseudo-container type for specialized "indexable" data types i.e. with a public identifier <em>key</em> member. Provides associative features of std::set and std::map in sequence containers (std::array, std::vector, std::deque and std::list), leveraging perfomance advantages of these types.  <a href="classstd_1_1indexer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a277f410feae48e1109ad6e71c6a314c9"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a277f410feae48e1109ad6e71c6a314c9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="indexer_8hpp.html#a277f410feae48e1109ad6e71c6a314c9">std::id_member</a> = decltype(declval&lt; T &gt;().key)</td></tr>
<tr class="memdesc:a277f410feae48e1109ad6e71c6a314c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Templated static SFINAE check for indexable types. It employs std::can_apply&lt;&gt; (cf. <a class="el" href="type__check_8hpp_source.html">type_check.hpp</a>) while testing specifically for the validity of a ::id member.  <a href="indexer_8hpp.html#a277f410feae48e1109ad6e71c6a314c9">More...</a><br /></td></tr>
<tr class="separator:a277f410feae48e1109ad6e71c6a314c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3788cb8472d469ef46f8c500f77ab2e3"><td class="memTemplParams" colspan="2"><a id="a3788cb8472d469ef46f8c500f77ab2e3" name="a3788cb8472d469ef46f8c500f77ab2e3"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a3788cb8472d469ef46f8c500f77ab2e3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::id_function</b> = decltype(declval&lt; T &gt;().key())</td></tr>
<tr class="separator:a3788cb8472d469ef46f8c500f77ab2e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3ef45a02e7667a0318d82ecf77131cb"><td class="memTemplParams" colspan="2"><a id="ac3ef45a02e7667a0318d82ecf77131cb" name="ac3ef45a02e7667a0318d82ecf77131cb"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ac3ef45a02e7667a0318d82ecf77131cb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::position_accessor</b> = decltype(declval&lt; T &gt;().operator[](0))</td></tr>
<tr class="separator:ac3ef45a02e7667a0318d82ecf77131cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ce38a8926e40ef46e7973fd9b891a2f"><td class="memTemplParams" colspan="2"><a id="a3ce38a8926e40ef46e7973fd9b891a2f" name="a3ce38a8926e40ef46e7973fd9b891a2f"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a3ce38a8926e40ef46e7973fd9b891a2f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::front_accessor</b> = decltype(declval&lt; T &gt;().front())</td></tr>
<tr class="separator:a3ce38a8926e40ef46e7973fd9b891a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6adf64e80ad6a9c43a7fd45e1c9458f"><td class="memTemplParams" colspan="2"><a id="af6adf64e80ad6a9c43a7fd45e1c9458f" name="af6adf64e80ad6a9c43a7fd45e1c9458f"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:af6adf64e80ad6a9c43a7fd45e1c9458f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::back_accessor</b> = decltype(declval&lt; T &gt;().back())</td></tr>
<tr class="separator:af6adf64e80ad6a9c43a7fd45e1c9458f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76370024d0e41002a12f4171fa98ba67"><td class="memTemplParams" colspan="2"><a id="a76370024d0e41002a12f4171fa98ba67" name="a76370024d0e41002a12f4171fa98ba67"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a76370024d0e41002a12f4171fa98ba67"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::front_pusher</b> = decltype(declval&lt; T &gt;().push_front())</td></tr>
<tr class="separator:a76370024d0e41002a12f4171fa98ba67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabb7e171615d75ca701b600518db82b4"><td class="memTemplParams" colspan="2"><a id="aabb7e171615d75ca701b600518db82b4" name="aabb7e171615d75ca701b600518db82b4"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aabb7e171615d75ca701b600518db82b4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::back_pusher</b> = decltype(declval&lt; T &gt;().push_back())</td></tr>
<tr class="separator:aabb7e171615d75ca701b600518db82b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1774d01aec50cab730f0c0354040f3d3"><td class="memTemplParams" colspan="2"><a id="a1774d01aec50cab730f0c0354040f3d3" name="a1774d01aec50cab730f0c0354040f3d3"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a1774d01aec50cab730f0c0354040f3d3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::front_emplacer</b> = decltype(declval&lt; T &gt;().emplace_front())</td></tr>
<tr class="separator:a1774d01aec50cab730f0c0354040f3d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03ea81c214835734ee8a01485f30fdc8"><td class="memTemplParams" colspan="2"><a id="a03ea81c214835734ee8a01485f30fdc8" name="a03ea81c214835734ee8a01485f30fdc8"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a03ea81c214835734ee8a01485f30fdc8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::back_emplacer</b> = decltype(declval&lt; T &gt;().emplace_back())</td></tr>
<tr class="separator:a03ea81c214835734ee8a01485f30fdc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75b856494437ffb94678913f127aff8f"><td class="memTemplParams" colspan="2"><a id="a75b856494437ffb94678913f127aff8f" name="a75b856494437ffb94678913f127aff8f"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a75b856494437ffb94678913f127aff8f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::front_popper</b> = decltype(declval&lt; T &gt;().pop_front())</td></tr>
<tr class="separator:a75b856494437ffb94678913f127aff8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2feff0324970c6224c0d6588f1b23056"><td class="memTemplParams" colspan="2"><a id="a2feff0324970c6224c0d6588f1b23056" name="a2feff0324970c6224c0d6588f1b23056"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a2feff0324970c6224c0d6588f1b23056"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::back_popper</b> = decltype(declval&lt; T &gt;().pop_back())</td></tr>
<tr class="separator:a2feff0324970c6224c0d6588f1b23056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28cd6080437e34dcd7399bc291bd30e2"><td class="memTemplParams" colspan="2"><a id="a28cd6080437e34dcd7399bc291bd30e2" name="a28cd6080437e34dcd7399bc291bd30e2"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a28cd6080437e34dcd7399bc291bd30e2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::has_id</b> = can_apply&lt; id_member, T &gt;</td></tr>
<tr class="separator:a28cd6080437e34dcd7399bc291bd30e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e58eaddd3341b898b9070f6b7625c15"><td class="memTemplParams" colspan="2"><a id="a2e58eaddd3341b898b9070f6b7625c15" name="a2e58eaddd3341b898b9070f6b7625c15"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a2e58eaddd3341b898b9070f6b7625c15"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::has_id_function</b> = can_apply&lt; id_function, T &gt;</td></tr>
<tr class="separator:a2e58eaddd3341b898b9070f6b7625c15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b523c5b2e496430624984e30f9b5b43"><td class="memTemplParams" colspan="2"><a id="a6b523c5b2e496430624984e30f9b5b43" name="a6b523c5b2e496430624984e30f9b5b43"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a6b523c5b2e496430624984e30f9b5b43"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::has_position_accessor</b> = can_apply&lt; position_accessor, T &gt;</td></tr>
<tr class="separator:a6b523c5b2e496430624984e30f9b5b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71fd7ade19d818ab6c42c8332e026311"><td class="memTemplParams" colspan="2"><a id="a71fd7ade19d818ab6c42c8332e026311" name="a71fd7ade19d818ab6c42c8332e026311"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a71fd7ade19d818ab6c42c8332e026311"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::has_front_accessor</b> = can_apply&lt; front_accessor, T &gt;</td></tr>
<tr class="separator:a71fd7ade19d818ab6c42c8332e026311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a636b3c2a630badd4dce39e6e98c4cb2e"><td class="memTemplParams" colspan="2"><a id="a636b3c2a630badd4dce39e6e98c4cb2e" name="a636b3c2a630badd4dce39e6e98c4cb2e"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a636b3c2a630badd4dce39e6e98c4cb2e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::has_back_accessor</b> = can_apply&lt; back_accessor, T &gt;</td></tr>
<tr class="separator:a636b3c2a630badd4dce39e6e98c4cb2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70bab5f7ca6d1de545d90652744b6cec"><td class="memTemplParams" colspan="2"><a id="a70bab5f7ca6d1de545d90652744b6cec" name="a70bab5f7ca6d1de545d90652744b6cec"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a70bab5f7ca6d1de545d90652744b6cec"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::has_front_pusher</b> = can_apply&lt; front_pusher, T &gt;</td></tr>
<tr class="separator:a70bab5f7ca6d1de545d90652744b6cec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65a7a09fc7363ffb034056cf69afe22a"><td class="memTemplParams" colspan="2"><a id="a65a7a09fc7363ffb034056cf69afe22a" name="a65a7a09fc7363ffb034056cf69afe22a"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a65a7a09fc7363ffb034056cf69afe22a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::has_back_pusher</b> = can_apply&lt; back_pusher, T &gt;</td></tr>
<tr class="separator:a65a7a09fc7363ffb034056cf69afe22a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf8b57c5d8e47029be6ae85ca6a1e99f"><td class="memTemplParams" colspan="2"><a id="adf8b57c5d8e47029be6ae85ca6a1e99f" name="adf8b57c5d8e47029be6ae85ca6a1e99f"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:adf8b57c5d8e47029be6ae85ca6a1e99f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::has_front_emplacer</b> = can_apply&lt; front_emplacer, T &gt;</td></tr>
<tr class="separator:adf8b57c5d8e47029be6ae85ca6a1e99f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0913acfa95076f9a1a30ff446b71afa6"><td class="memTemplParams" colspan="2"><a id="a0913acfa95076f9a1a30ff446b71afa6" name="a0913acfa95076f9a1a30ff446b71afa6"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a0913acfa95076f9a1a30ff446b71afa6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::has_back_emplacer</b> = can_apply&lt; back_emplacer, T &gt;</td></tr>
<tr class="separator:a0913acfa95076f9a1a30ff446b71afa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55f28b999015fea1f17dda6167906531"><td class="memTemplParams" colspan="2"><a id="a55f28b999015fea1f17dda6167906531" name="a55f28b999015fea1f17dda6167906531"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a55f28b999015fea1f17dda6167906531"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::has_front_popper</b> = can_apply&lt; front_popper, T &gt;</td></tr>
<tr class="separator:a55f28b999015fea1f17dda6167906531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d62621af281a6be392744bc2d6eb5e2"><td class="memTemplParams" colspan="2"><a id="a3d62621af281a6be392744bc2d6eb5e2" name="a3d62621af281a6be392744bc2d6eb5e2"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a3d62621af281a6be392744bc2d6eb5e2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::has_back_popper</b> = can_apply&lt; back_popper, T &gt;</td></tr>
<tr class="separator:a3d62621af281a6be392744bc2d6eb5e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a560b478532185401adead77a6d5d8350"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Key  = string, bool Locked = false&gt; </td></tr>
<tr class="memitem:a560b478532185401adead77a6d5d8350"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="indexer_8hpp.html#a560b478532185401adead77a6d5d8350">std::index</a> = indexer&lt; std::vector&lt; <a class="el" href="classstd_1_1tagged.html">std::tagged</a>&lt; T, Key &gt; &gt;, T, Locked &gt;</td></tr>
<tr class="memdesc:a560b478532185401adead77a6d5d8350"><td class="mdescLeft">&#160;</td><td class="mdescRight">Public <a class="el" href="classstd_1_1indexer.html" title="Simple extensible generic container adapter that provides high-level indexing/key functionality to Co...">std::indexer</a> specialization to std::vector with text keys, and generalizing over given type T through std::tagged&lt;&gt; indexable wrapper.  <a href="indexer_8hpp.html#a560b478532185401adead77a6d5d8350">More...</a><br /></td></tr>
<tr class="separator:a560b478532185401adead77a6d5d8350"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae9a0306382fc3b5e85c8cdf7ba128a57"><td class="memTemplParams" colspan="2"><a id="ae9a0306382fc3b5e85c8cdf7ba128a57" name="ae9a0306382fc3b5e85c8cdf7ba128a57"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae9a0306382fc3b5e85c8cdf7ba128a57"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::can_be_indexed</b> ()</td></tr>
<tr class="separator:ae9a0306382fc3b5e85c8cdf7ba128a57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e378a5dd6d35fecd2cce246495b8f8c"><td class="memTemplParams" colspan="2"><a id="a1e378a5dd6d35fecd2cce246495b8f8c" name="a1e378a5dd6d35fecd2cce246495b8f8c"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a1e378a5dd6d35fecd2cce246495b8f8c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::can_be_replaced_by</b> ()</td></tr>
<tr class="separator:a1e378a5dd6d35fecd2cce246495b8f8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6441e8d91cde96b06d80c4d4f758672"><td class="memTemplParams" colspan="2"><a id="ac6441e8d91cde96b06d80c4d4f758672" name="ac6441e8d91cde96b06d80c4d4f758672"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac6441e8d91cde96b06d80c4d4f758672"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::is_position_accessible</b> ()</td></tr>
<tr class="separator:ac6441e8d91cde96b06d80c4d4f758672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a875c105b7b148959572fb444e84e9a59"><td class="memTemplParams" colspan="2"><a id="a875c105b7b148959572fb444e84e9a59" name="a875c105b7b148959572fb444e84e9a59"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a875c105b7b148959572fb444e84e9a59"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::has_front</b> ()</td></tr>
<tr class="separator:a875c105b7b148959572fb444e84e9a59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af31e492208c5faa7e8b81a39cdc510ed"><td class="memTemplParams" colspan="2"><a id="af31e492208c5faa7e8b81a39cdc510ed" name="af31e492208c5faa7e8b81a39cdc510ed"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:af31e492208c5faa7e8b81a39cdc510ed"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::has_back</b> ()</td></tr>
<tr class="separator:af31e492208c5faa7e8b81a39cdc510ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bf018e9db166120c5160c30c225593b"><td class="memTemplParams" colspan="2"><a id="a9bf018e9db166120c5160c30c225593b" name="a9bf018e9db166120c5160c30c225593b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9bf018e9db166120c5160c30c225593b"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::is_front_pushable</b> ()</td></tr>
<tr class="separator:a9bf018e9db166120c5160c30c225593b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed0b3c2cd9104e5b3eeef64d4982aabc"><td class="memTemplParams" colspan="2"><a id="aed0b3c2cd9104e5b3eeef64d4982aabc" name="aed0b3c2cd9104e5b3eeef64d4982aabc"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aed0b3c2cd9104e5b3eeef64d4982aabc"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::is_back_pushable</b> ()</td></tr>
<tr class="separator:aed0b3c2cd9104e5b3eeef64d4982aabc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34a74bc5b32b62b1cdd7cb185aecec44"><td class="memTemplParams" colspan="2"><a id="a34a74bc5b32b62b1cdd7cb185aecec44" name="a34a74bc5b32b62b1cdd7cb185aecec44"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a34a74bc5b32b62b1cdd7cb185aecec44"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::is_front_emplaceable</b> ()</td></tr>
<tr class="separator:a34a74bc5b32b62b1cdd7cb185aecec44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06819caafcb7a19181c10c608278c5ac"><td class="memTemplParams" colspan="2"><a id="a06819caafcb7a19181c10c608278c5ac" name="a06819caafcb7a19181c10c608278c5ac"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a06819caafcb7a19181c10c608278c5ac"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::is_back_emplaceable</b> ()</td></tr>
<tr class="separator:a06819caafcb7a19181c10c608278c5ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af50ef821bf161602b9d579a3bba7bd"><td class="memTemplParams" colspan="2"><a id="a5af50ef821bf161602b9d579a3bba7bd" name="a5af50ef821bf161602b9d579a3bba7bd"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5af50ef821bf161602b9d579a3bba7bd"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::is_front_poppable</b> ()</td></tr>
<tr class="separator:a5af50ef821bf161602b9d579a3bba7bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b9a6be520ecfd0fb7711088048cc706"><td class="memTemplParams" colspan="2"><a id="a0b9a6be520ecfd0fb7711088048cc706" name="a0b9a6be520ecfd0fb7711088048cc706"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0b9a6be520ecfd0fb7711088048cc706"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>std::is_back_poppable</b> ()</td></tr>
<tr class="separator:a0b9a6be520ecfd0fb7711088048cc706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a021c8da8ca2b5d7e0a640de2bf8c1b23"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename T  = typename Container::value_type, bool Locked = false, typename... Args&gt; </td></tr>
<tr class="memitem:a021c8da8ca2b5d7e0a640de2bf8c1b23"><td class="memTemplItemLeft" align="right" valign="top">indexer&lt; Container, T, Locked &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="indexer_8hpp.html#a021c8da8ca2b5d7e0a640de2bf8c1b23">std::make_indexer</a> (const initializer_list&lt; typename indexer&lt; Container, T, Locked &gt;::key_type &gt; keys, Args... args)</td></tr>
<tr class="memdesc:a021c8da8ca2b5d7e0a640de2bf8c1b23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility constructor that allows inline initialization of an indexer object and its key set.  <a href="indexer_8hpp.html#a021c8da8ca2b5d7e0a640de2bf8c1b23">More...</a><br /></td></tr>
<tr class="separator:a021c8da8ca2b5d7e0a640de2bf8c1b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Header file providing declaration &amp; definition of std::indexer&lt;&gt; class template, as well as specializations std::index&lt;&gt; and std::series&lt;&gt;. </p>
<dl class="section author"><dt>Author</dt><dd>João André</dd></dl>
<p>std::indexer&lt;&gt; is a pseudo-container class template i.e. container adapter (as per STL definition), that implements high-level indexing &amp; sorting functionality to STL's sequence containers, while also providing a pulic interface matching STL's <em>Container</em> and <em>SequenceContainer</em> named requirements. This means by itself it can be treated as a container and will work with any of STL's tools (e.g. &lt;utility&gt;), while being versatile enough</p>
<p >While STL already provides associative containers in std:map&lt;&gt; and std::set&lt;&gt;, the major advantage of std::indexer&lt;&gt; is that it leverages the performance edge of different sequence containers (std::array, std::vector, std::deque, etc), makes no assumption on the ordering/sorting of the underlying data, can be locked to prevent dynamic resizing operations, maintains efficient random access to elements, is extensible, and thus is versatile enough to fit differerent usage scenarios. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a277f410feae48e1109ad6e71c6a314c9" name="a277f410feae48e1109ad6e71c6a314c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a277f410feae48e1109ad6e71c6a314c9">&#9670;&nbsp;</a></span>id_member</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="indexer_8hpp.html#a277f410feae48e1109ad6e71c6a314c9">std::id_member</a> = typedef decltype(declval&lt;T&gt;().key)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Templated static SFINAE check for indexable types. It employs std::can_apply&lt;&gt; (cf. <a class="el" href="type__check_8hpp_source.html">type_check.hpp</a>) while testing specifically for the validity of a ::id member. </p>
<dl class="section note"><dt>Note</dt><dd>At this stage, std::indexer&lt;&gt; requires: 1) A Container type that meets STL's <em>Container</em> &amp; <em>SequenceContainer</em> mandatory requirements holding objects of 2) An 'indexable' type that provide a valid public non-const 'id' member.</dd>
<dd>
With generic use in mind, <a class="el" href="classstd_1_1indexer.html" title="Simple extensible generic container adapter that provides high-level indexing/key functionality to Co...">std::indexer</a> makes minimal assumptions on data type. Any STL sequence container can be used with any class/struct that provides an 'id' member. However, it was extensively tested using std::vector&lt;&gt; as the underlying container and std::tagged&lt;&gt; as the indexable type (that itself wraps around any other type). </dd></dl>

</div>
</div>
<a id="a560b478532185401adead77a6d5d8350" name="a560b478532185401adead77a6d5d8350"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a560b478532185401adead77a6d5d8350">&#9670;&nbsp;</a></span>index</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Key  = string, bool Locked = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="indexer_8hpp.html#a560b478532185401adead77a6d5d8350">std::index</a> = typedef indexer&lt; std::vector&lt; <a class="el" href="classstd_1_1tagged.html">std::tagged</a>&lt; T, Key &gt; &gt;, T, Locked &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Public <a class="el" href="classstd_1_1indexer.html" title="Simple extensible generic container adapter that provides high-level indexing/key functionality to Co...">std::indexer</a> specialization to std::vector with text keys, and generalizing over given type T through std::tagged&lt;&gt; indexable wrapper. </p>
<dl class="section note"><dt>Note</dt><dd>Practical/intuitive specialization, exploiting <a class="el" href="classstd_1_1indexer.html" title="Simple extensible generic container adapter that provides high-level indexing/key functionality to Co...">std::indexer</a> interface to provide a pseudo-container with associative properties.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Data type (<em>not</em> the container data type!) </td></tr>
    <tr><td class="paramname">Locked</td><td>Whether container is resizeable after initialization. Defaults to false (expandable container). </td></tr>
    <tr><td class="paramname">Id</td><td>Type of key/identifier. Defautls to string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a021c8da8ca2b5d7e0a640de2bf8c1b23" name="a021c8da8ca2b5d7e0a640de2bf8c1b23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a021c8da8ca2b5d7e0a640de2bf8c1b23">&#9670;&nbsp;</a></span>make_indexer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename T  = typename Container::value_type, bool Locked = false, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">indexer&lt; Container, T, Locked &gt; std::make_indexer </td>
          <td>(</td>
          <td class="paramtype">const initializer_list&lt; typename <a class="el" href="classstd_1_1indexer.html">indexer</a>&lt; Container, T, Locked &gt;::key_type &gt;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility constructor that allows inline initialization of an indexer object and its key set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">keys</td><td>Key values to be assigned to elements of resulting indexer&lt;&gt;. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Argument list to be passed to the constructor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>Generic container of key/tagged type instances. Must fit STL's Container &amp; SequenceContainer (partial) requirements. </td></tr>
    <tr><td class="paramname">T</td><td>Public/interface type. </td></tr>
    <tr><td class="paramname">Locked</td><td>Whether runtime size manipulation is allowed after initialization. Useful when size of the container does not change but elements do. </td></tr>
    <tr><td class="paramname">Args</td><td>Variadic parameter pack describing types of arguments passed to constructor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>indexer&lt;&gt; instance with given <em>keys</em>. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_5c878092e0fc84e9ec68d194cabc16d2.html">storage</a></li><li class="navelem"><a class="el" href="indexer_8hpp.html">indexer.hpp</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3 </li>
  </ul>
</div>
</body>
</html>
