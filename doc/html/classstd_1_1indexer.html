<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>storage: std::indexer&lt; Container, T, Locked &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src=""/></td>
  <td id="projectalign">
   <div id="projectname">storage<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">C++ header-only library providing generic extensions to STL containers.</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classstd_1_1indexer.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classstd_1_1indexer-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">std::indexer&lt; Container, T, Locked &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Simple extensible generic container adapter that provides high-level indexing/key functionality to <em>Container</em>, while maintaining a customizable public interface of a container of <em>T</em>, in line with STL's <em>SequenceContainer</em> named requirements. Represents a pseudo-container type for specialized "indexable" data types i.e. with a public identifier <em>key</em> member. Provides associative features of std::set and std::map in sequence containers (std::array, std::vector, std::deque and std::list), leveraging perfomance advantages of these types.  
 <a href="classstd_1_1indexer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="indexer_8hpp_source.html">indexer.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ae759f8b0b7df8e5e56c8498f66a59dcd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstd_1_1indexer.html#ae759f8b0b7df8e5e56c8498f66a59dcd">value_type</a> = T</td></tr>
<tr class="memdesc:ae759f8b0b7df8e5e56c8498f66a59dcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static assertions on data types/template arguments. Required in order to avoid ill-formed expressions within class definition.  <a href="classstd_1_1indexer.html#ae759f8b0b7df8e5e56c8498f66a59dcd">More...</a><br /></td></tr>
<tr class="separator:ae759f8b0b7df8e5e56c8498f66a59dcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d5553ed1fd172b6b5208ac8661146e3"><td class="memItemLeft" align="right" valign="top"><a id="a9d5553ed1fd172b6b5208ac8661146e3" name="a9d5553ed1fd172b6b5208ac8661146e3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>container_type</b> = Container</td></tr>
<tr class="memdesc:a9d5553ed1fd172b6b5208ac8661146e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container type. Provided to fit with STL 'Container' requirements. <br /></td></tr>
<tr class="separator:a9d5553ed1fd172b6b5208ac8661146e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2ee55885c05959226722520959fa96c"><td class="memItemLeft" align="right" valign="top"><a id="ac2ee55885c05959226722520959fa96c" name="ac2ee55885c05959226722520959fa96c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>element_type</b> = typename Container::value_type</td></tr>
<tr class="memdesc:ac2ee55885c05959226722520959fa96c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container element type. Must be an indexable type implicitly convertible to &amp; assignable from T. <br /></td></tr>
<tr class="separator:ac2ee55885c05959226722520959fa96c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af19cd09a80a82ecba0b08482703c478f"><td class="memItemLeft" align="right" valign="top"><a id="af19cd09a80a82ecba0b08482703c478f" name="af19cd09a80a82ecba0b08482703c478f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>element_reference</b> = <a class="el" href="classstd_1_1indexer.html#ac2ee55885c05959226722520959fa96c">element_type</a> &amp;</td></tr>
<tr class="memdesc:af19cd09a80a82ecba0b08482703c478f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container element reference type. <br /></td></tr>
<tr class="separator:af19cd09a80a82ecba0b08482703c478f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b21e6a5992ff589b9a17a95f58f89f3"><td class="memItemLeft" align="right" valign="top"><a id="a2b21e6a5992ff589b9a17a95f58f89f3" name="a2b21e6a5992ff589b9a17a95f58f89f3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>element_const_reference</b> = const <a class="el" href="classstd_1_1indexer.html#ac2ee55885c05959226722520959fa96c">element_type</a> &amp;</td></tr>
<tr class="memdesc:a2b21e6a5992ff589b9a17a95f58f89f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container element cons reference type. <br /></td></tr>
<tr class="separator:a2b21e6a5992ff589b9a17a95f58f89f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a677771da29cdc65d7db881149cf4abdc"><td class="memItemLeft" align="right" valign="top"><a id="a677771da29cdc65d7db881149cf4abdc" name="a677771da29cdc65d7db881149cf4abdc"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>key_type</b> = decltype(declval&lt; <a class="el" href="classstd_1_1indexer.html#ac2ee55885c05959226722520959fa96c">element_type</a> &gt;().<a class="el" href="classstd_1_1indexer.html#abdfc9ddeeb8ba66f9927f58b684dc8b5">key</a>)</td></tr>
<tr class="memdesc:a677771da29cdc65d7db881149cf4abdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Descriptor type. <br /></td></tr>
<tr class="separator:a677771da29cdc65d7db881149cf4abdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59e97f3ead469e9d8d383f8a10f46a56"><td class="memItemLeft" align="right" valign="top"><a id="a59e97f3ead469e9d8d383f8a10f46a56" name="a59e97f3ead469e9d8d383f8a10f46a56"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b> = typename Container::size_type</td></tr>
<tr class="memdesc:a59e97f3ead469e9d8d383f8a10f46a56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size/index type. Provided to fit with STL 'Container' requirements. <br /></td></tr>
<tr class="separator:a59e97f3ead469e9d8d383f8a10f46a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2db1ee5c5641d5faaef45747c63ac37"><td class="memItemLeft" align="right" valign="top"><a id="ae2db1ee5c5641d5faaef45747c63ac37" name="ae2db1ee5c5641d5faaef45747c63ac37"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>reference</b> = T &amp;</td></tr>
<tr class="memdesc:ae2db1ee5c5641d5faaef45747c63ac37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value reference type. Provided to fit with STL 'Container' requirements. <br /></td></tr>
<tr class="separator:ae2db1ee5c5641d5faaef45747c63ac37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfaec2da712e26c1c02b7433952f6599"><td class="memItemLeft" align="right" valign="top"><a id="abfaec2da712e26c1c02b7433952f6599" name="abfaec2da712e26c1c02b7433952f6599"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_reference</b> = const T &amp;</td></tr>
<tr class="memdesc:abfaec2da712e26c1c02b7433952f6599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value const reference type. Provided to fit with STL 'Container' requirements. <br /></td></tr>
<tr class="separator:abfaec2da712e26c1c02b7433952f6599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab561f176e9d82a674e186ff6e33ee81f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstd_1_1indexer.html#ab561f176e9d82a674e186ff6e33ee81f">iterator</a> = <a class="el" href="classstd_1_1cast__iterator.html">cast_iterator</a>&lt; Container, T &gt;</td></tr>
<tr class="memdesc:ab561f176e9d82a674e186ff6e33ee81f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator type. Provided to fit with STL 'Container' requirements.  <a href="classstd_1_1indexer.html#ab561f176e9d82a674e186ff6e33ee81f">More...</a><br /></td></tr>
<tr class="separator:ab561f176e9d82a674e186ff6e33ee81f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d435d880c6fed943652f1fb924b6338"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstd_1_1indexer.html#a1d435d880c6fed943652f1fb924b6338">const_iterator</a> = <a class="el" href="classstd_1_1cast__iterator.html">cast_iterator</a>&lt; const Container, const T &gt;</td></tr>
<tr class="memdesc:a1d435d880c6fed943652f1fb924b6338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const iterator type. Provided to fit with STL 'Container' requirements.  <a href="classstd_1_1indexer.html#a1d435d880c6fed943652f1fb924b6338">More...</a><br /></td></tr>
<tr class="separator:a1d435d880c6fed943652f1fb924b6338"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a356d97a5ba7a2ea11fcc8f88373b969c"><td class="memTemplParams" colspan="2">template&lt;typename... Args, typename  = typename enable_if&lt; is_constructible&lt; Container, Args... &gt;::value &gt;::type&gt; </td></tr>
<tr class="memitem:a356d97a5ba7a2ea11fcc8f88373b969c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstd_1_1indexer.html#a356d97a5ba7a2ea11fcc8f88373b969c">indexer</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a356d97a5ba7a2ea11fcc8f88373b969c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new instance, passing the arguments to the Container constructor (Container::Container(...))  <a href="classstd_1_1indexer.html#a356d97a5ba7a2ea11fcc8f88373b969c">More...</a><br /></td></tr>
<tr class="separator:a356d97a5ba7a2ea11fcc8f88373b969c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b313b2b516e0084fdbf8677dc1d4c85"><td class="memTemplParams" colspan="2">template&lt;bool oLocked&gt; </td></tr>
<tr class="memitem:a4b313b2b516e0084fdbf8677dc1d4c85"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstd_1_1indexer.html#a4b313b2b516e0084fdbf8677dc1d4c85">indexer</a> (const <a class="el" href="classstd_1_1indexer.html">indexer</a>&lt; Container, T, oLocked &gt; &amp;other)</td></tr>
<tr class="memdesc:a4b313b2b516e0084fdbf8677dc1d4c85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new (copied) instance.  <a href="classstd_1_1indexer.html#a4b313b2b516e0084fdbf8677dc1d4c85">More...</a><br /></td></tr>
<tr class="separator:a4b313b2b516e0084fdbf8677dc1d4c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e35d38c3fabb61c723d1505f6ff588e"><td class="memTemplParams" colspan="2">template&lt;bool oLocked&gt; </td></tr>
<tr class="memitem:a8e35d38c3fabb61c723d1505f6ff588e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstd_1_1indexer.html#a8e35d38c3fabb61c723d1505f6ff588e">indexer</a> (<a class="el" href="classstd_1_1indexer.html">indexer</a>&lt; Container, T, oLocked &gt; &amp;&amp;other)</td></tr>
<tr class="memdesc:a8e35d38c3fabb61c723d1505f6ff588e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new (moved) instance.  <a href="classstd_1_1indexer.html#a8e35d38c3fabb61c723d1505f6ff588e">More...</a><br /></td></tr>
<tr class="separator:a8e35d38c3fabb61c723d1505f6ff588e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c45b3b3fa3f3f7c81ce0295f3d4a6ae"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstd_1_1indexer.html#a9c45b3b3fa3f3f7c81ce0295f3d4a6ae">indexer</a> (std::initializer_list&lt; T &gt; data)</td></tr>
<tr class="memdesc:a9c45b3b3fa3f3f7c81ce0295f3d4a6ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new instance, from a braced initializer list of <em>T</em> elements.  <a href="classstd_1_1indexer.html#a9c45b3b3fa3f3f7c81ce0295f3d4a6ae">More...</a><br /></td></tr>
<tr class="separator:a9c45b3b3fa3f3f7c81ce0295f3d4a6ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f0bb9a0aad009349fb9d3a86cc724a4"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstd_1_1indexer.html#a2f0bb9a0aad009349fb9d3a86cc724a4">~indexer</a> ()=default</td></tr>
<tr class="memdesc:a2f0bb9a0aad009349fb9d3a86cc724a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the object.  <a href="classstd_1_1indexer.html#a2f0bb9a0aad009349fb9d3a86cc724a4">More...</a><br /></td></tr>
<tr class="separator:a2f0bb9a0aad009349fb9d3a86cc724a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa60b1004706755f1378b22ac5967365a"><td class="memTemplParams" colspan="2">template&lt;bool oLocked&gt; </td></tr>
<tr class="memitem:aa60b1004706755f1378b22ac5967365a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1indexer.html">indexer</a>&lt; Container, T, Locked &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstd_1_1indexer.html#aa60b1004706755f1378b22ac5967365a">operator=</a> (const <a class="el" href="classstd_1_1indexer.html">indexer</a>&lt; Container, T, oLocked &gt; &amp;other)</td></tr>
<tr class="memdesc:aa60b1004706755f1378b22ac5967365a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <a href="classstd_1_1indexer.html#aa60b1004706755f1378b22ac5967365a">More...</a><br /></td></tr>
<tr class="separator:aa60b1004706755f1378b22ac5967365a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa045218a06b84b97d094362083b5a486"><td class="memTemplParams" colspan="2">template&lt;bool oLocked&gt; </td></tr>
<tr class="memitem:aa045218a06b84b97d094362083b5a486"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1indexer.html">indexer</a>&lt; Container, T, Locked &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstd_1_1indexer.html#aa045218a06b84b97d094362083b5a486">operator=</a> (<a class="el" href="classstd_1_1indexer.html">indexer</a>&lt; Container, T, oLocked &gt; &amp;&amp;other)</td></tr>
<tr class="memdesc:aa045218a06b84b97d094362083b5a486"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <a href="classstd_1_1indexer.html#aa045218a06b84b97d094362083b5a486">More...</a><br /></td></tr>
<tr class="separator:aa045218a06b84b97d094362083b5a486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e5fac2a6c305177ba9834949af44dd6"><td class="memTemplParams" colspan="2">template&lt;typename Arg  = key_type, typename  = typename enable_if&lt; !is_convertible&lt; Arg, size_type &gt;::value &gt;::type&gt; </td></tr>
<tr class="memitem:a2e5fac2a6c305177ba9834949af44dd6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1indexer.html#ae2db1ee5c5641d5faaef45747c63ac37">reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstd_1_1indexer.html#a2e5fac2a6c305177ba9834949af44dd6">operator()</a> (<a class="el" href="classstd_1_1indexer.html#a59e97f3ead469e9d8d383f8a10f46a56">size_type</a> pos)</td></tr>
<tr class="memdesc:a2e5fac2a6c305177ba9834949af44dd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access container element.  <a href="classstd_1_1indexer.html#a2e5fac2a6c305177ba9834949af44dd6">More...</a><br /></td></tr>
<tr class="separator:a2e5fac2a6c305177ba9834949af44dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87e7541c4b7e2bada8f8001eaab88480"><td class="memTemplParams" colspan="2">template&lt;typename Arg  = key_type, typename  = typename enable_if&lt; !is_convertible&lt; Arg, size_type &gt;::value &gt;::type&gt; </td></tr>
<tr class="memitem:a87e7541c4b7e2bada8f8001eaab88480"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1indexer.html#abfaec2da712e26c1c02b7433952f6599">const_reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstd_1_1indexer.html#a87e7541c4b7e2bada8f8001eaab88480">operator()</a> (<a class="el" href="classstd_1_1indexer.html#a59e97f3ead469e9d8d383f8a10f46a56">size_type</a> pos) const</td></tr>
<tr class="memdesc:a87e7541c4b7e2bada8f8001eaab88480"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access container element (const overload).  <a href="classstd_1_1indexer.html#a87e7541c4b7e2bada8f8001eaab88480">More...</a><br /></td></tr>
<tr class="separator:a87e7541c4b7e2bada8f8001eaab88480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aee8e61220c8fb64cc7a3647b991ff8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1indexer.html#ae2db1ee5c5641d5faaef45747c63ac37">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstd_1_1indexer.html#a3aee8e61220c8fb64cc7a3647b991ff8">operator()</a> (const <a class="el" href="classstd_1_1indexer.html#a677771da29cdc65d7db881149cf4abdc">key_type</a> &amp;<a class="el" href="classstd_1_1indexer.html#abdfc9ddeeb8ba66f9927f58b684dc8b5">key</a>)</td></tr>
<tr class="memdesc:a3aee8e61220c8fb64cc7a3647b991ff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access container element.  <a href="classstd_1_1indexer.html#a3aee8e61220c8fb64cc7a3647b991ff8">More...</a><br /></td></tr>
<tr class="separator:a3aee8e61220c8fb64cc7a3647b991ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4eccd9de572f750b182be285a66b767"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1indexer.html#abfaec2da712e26c1c02b7433952f6599">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstd_1_1indexer.html#ac4eccd9de572f750b182be285a66b767">operator()</a> (const <a class="el" href="classstd_1_1indexer.html#a677771da29cdc65d7db881149cf4abdc">key_type</a> &amp;<a class="el" href="classstd_1_1indexer.html#abdfc9ddeeb8ba66f9927f58b684dc8b5">key</a>) const</td></tr>
<tr class="memdesc:ac4eccd9de572f750b182be285a66b767"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access container element (const overload).  <a href="classstd_1_1indexer.html#ac4eccd9de572f750b182be285a66b767">More...</a><br /></td></tr>
<tr class="separator:ac4eccd9de572f750b182be285a66b767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c85d26bb9699dbdcd146f4b673339cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1indexer.html#ae2db1ee5c5641d5faaef45747c63ac37">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstd_1_1indexer.html#a5c85d26bb9699dbdcd146f4b673339cb">operator[]</a> (<a class="el" href="classstd_1_1indexer.html#a59e97f3ead469e9d8d383f8a10f46a56">size_type</a> pos)</td></tr>
<tr class="memdesc:a5c85d26bb9699dbdcd146f4b673339cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access container element.  <a href="classstd_1_1indexer.html#a5c85d26bb9699dbdcd146f4b673339cb">More...</a><br /></td></tr>
<tr class="separator:a5c85d26bb9699dbdcd146f4b673339cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0243ac580a0039246757ee371e1ffba3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1indexer.html#abfaec2da712e26c1c02b7433952f6599">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstd_1_1indexer.html#a0243ac580a0039246757ee371e1ffba3">operator[]</a> (<a class="el" href="classstd_1_1indexer.html#a59e97f3ead469e9d8d383f8a10f46a56">size_type</a> pos) const</td></tr>
<tr class="memdesc:a0243ac580a0039246757ee371e1ffba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access container element (const overload).  <a href="classstd_1_1indexer.html#a0243ac580a0039246757ee371e1ffba3">More...</a><br /></td></tr>
<tr class="separator:a0243ac580a0039246757ee371e1ffba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81010896f3babe94a6488fe1d6fbd8cb"><td class="memTemplParams" colspan="2">template&lt;typename Arg  = key_type, typename  = typename enable_if&lt; !is_convertible&lt; Arg, size_type &gt;::value &gt;::type&gt; </td></tr>
<tr class="memitem:a81010896f3babe94a6488fe1d6fbd8cb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1indexer.html#ae2db1ee5c5641d5faaef45747c63ac37">reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstd_1_1indexer.html#a81010896f3babe94a6488fe1d6fbd8cb">operator[]</a> (const <a class="el" href="classstd_1_1indexer.html#a677771da29cdc65d7db881149cf4abdc">key_type</a> &amp;<a class="el" href="classstd_1_1indexer.html#abdfc9ddeeb8ba66f9927f58b684dc8b5">key</a>)</td></tr>
<tr class="memdesc:a81010896f3babe94a6488fe1d6fbd8cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access container element.  <a href="classstd_1_1indexer.html#a81010896f3babe94a6488fe1d6fbd8cb">More...</a><br /></td></tr>
<tr class="separator:a81010896f3babe94a6488fe1d6fbd8cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67dd9c5bddcdd98fe37b0374576799fa"><td class="memTemplParams" colspan="2">template&lt;typename Arg  = key_type, typename  = typename enable_if&lt; !is_convertible&lt; Arg, size_type &gt;::value &gt;::type&gt; </td></tr>
<tr class="memitem:a67dd9c5bddcdd98fe37b0374576799fa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1indexer.html#abfaec2da712e26c1c02b7433952f6599">const_reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstd_1_1indexer.html#a67dd9c5bddcdd98fe37b0374576799fa">operator[]</a> (const <a class="el" href="classstd_1_1indexer.html#a677771da29cdc65d7db881149cf4abdc">key_type</a> &amp;<a class="el" href="classstd_1_1indexer.html#abdfc9ddeeb8ba66f9927f58b684dc8b5">key</a>) const</td></tr>
<tr class="memdesc:a67dd9c5bddcdd98fe37b0374576799fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access container element (const overload).  <a href="classstd_1_1indexer.html#a67dd9c5bddcdd98fe37b0374576799fa">More...</a><br /></td></tr>
<tr class="separator:a67dd9c5bddcdd98fe37b0374576799fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ed5217ce0360fcc00207cc4b0da4a5a"><td class="memTemplParams" colspan="2">template&lt;typename oT  = value_type&gt; </td></tr>
<tr class="memitem:a8ed5217ce0360fcc00207cc4b0da4a5a"><td class="memTemplItemLeft" align="right" valign="top">oT &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstd_1_1indexer.html#a8ed5217ce0360fcc00207cc4b0da4a5a">at</a> (<a class="el" href="classstd_1_1indexer.html#a59e97f3ead469e9d8d383f8a10f46a56">size_type</a> pos)</td></tr>
<tr class="memdesc:a8ed5217ce0360fcc00207cc4b0da4a5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access container element.  <a href="classstd_1_1indexer.html#a8ed5217ce0360fcc00207cc4b0da4a5a">More...</a><br /></td></tr>
<tr class="separator:a8ed5217ce0360fcc00207cc4b0da4a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b5ad9f44d57000afca5cc1822869796"><td class="memTemplParams" colspan="2">template&lt;typename oT  = value_type&gt; </td></tr>
<tr class="memitem:a3b5ad9f44d57000afca5cc1822869796"><td class="memTemplItemLeft" align="right" valign="top">const oT &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstd_1_1indexer.html#a3b5ad9f44d57000afca5cc1822869796">at</a> (<a class="el" href="classstd_1_1indexer.html#a59e97f3ead469e9d8d383f8a10f46a56">size_type</a> pos) const</td></tr>
<tr class="memdesc:a3b5ad9f44d57000afca5cc1822869796"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access container element (const overload).  <a href="classstd_1_1indexer.html#a3b5ad9f44d57000afca5cc1822869796">More...</a><br /></td></tr>
<tr class="separator:a3b5ad9f44d57000afca5cc1822869796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e3c9c39df36e6067a26df3d3d6eb03"><td class="memTemplParams" colspan="2">template&lt;typename oT  = value_type, typename Arg  = key_type, typename  = typename enable_if&lt; !is_convertible&lt; Arg, size_type &gt;::value &gt;::type&gt; </td></tr>
<tr class="memitem:a14e3c9c39df36e6067a26df3d3d6eb03"><td class="memTemplItemLeft" align="right" valign="top">oT &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstd_1_1indexer.html#a14e3c9c39df36e6067a26df3d3d6eb03">at</a> (const <a class="el" href="classstd_1_1indexer.html#a677771da29cdc65d7db881149cf4abdc">key_type</a> &amp;<a class="el" href="classstd_1_1indexer.html#abdfc9ddeeb8ba66f9927f58b684dc8b5">key</a>)</td></tr>
<tr class="memdesc:a14e3c9c39df36e6067a26df3d3d6eb03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access container element.  <a href="classstd_1_1indexer.html#a14e3c9c39df36e6067a26df3d3d6eb03">More...</a><br /></td></tr>
<tr class="separator:a14e3c9c39df36e6067a26df3d3d6eb03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa98fc0b290777197dd753d149bef5e4e"><td class="memTemplParams" colspan="2">template&lt;typename oT  = value_type, typename Arg  = key_type, typename  = typename enable_if&lt; !is_convertible&lt; Arg, size_type &gt;::value &gt;::type&gt; </td></tr>
<tr class="memitem:aa98fc0b290777197dd753d149bef5e4e"><td class="memTemplItemLeft" align="right" valign="top">const oT &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstd_1_1indexer.html#aa98fc0b290777197dd753d149bef5e4e">at</a> (const <a class="el" href="classstd_1_1indexer.html#a677771da29cdc65d7db881149cf4abdc">key_type</a> &amp;<a class="el" href="classstd_1_1indexer.html#abdfc9ddeeb8ba66f9927f58b684dc8b5">key</a>) const</td></tr>
<tr class="memdesc:aa98fc0b290777197dd753d149bef5e4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access container element (const overload).  <a href="classstd_1_1indexer.html#aa98fc0b290777197dd753d149bef5e4e">More...</a><br /></td></tr>
<tr class="separator:aa98fc0b290777197dd753d149bef5e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56604ec6f2532c9f5ea37ad538132525"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classstd_1_1indexer.html#a59e97f3ead469e9d8d383f8a10f46a56">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstd_1_1indexer.html#a56604ec6f2532c9f5ea37ad538132525">find</a> (const <a class="el" href="classstd_1_1indexer.html#a677771da29cdc65d7db881149cf4abdc">key_type</a> &amp;<a class="el" href="classstd_1_1indexer.html#abdfc9ddeeb8ba66f9927f58b684dc8b5">key</a>) const noexcept</td></tr>
<tr class="memdesc:a56604ec6f2532c9f5ea37ad538132525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get element position from its identifier.  <a href="classstd_1_1indexer.html#a56604ec6f2532c9f5ea37ad538132525">More...</a><br /></td></tr>
<tr class="separator:a56604ec6f2532c9f5ea37ad538132525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdfc9ddeeb8ba66f9927f58b684dc8b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1indexer.html#a677771da29cdc65d7db881149cf4abdc">key_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstd_1_1indexer.html#abdfc9ddeeb8ba66f9927f58b684dc8b5">key</a> (<a class="el" href="classstd_1_1indexer.html#a59e97f3ead469e9d8d383f8a10f46a56">size_type</a> pos)</td></tr>
<tr class="memdesc:abdfc9ddeeb8ba66f9927f58b684dc8b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access element key/identifier.  <a href="classstd_1_1indexer.html#abdfc9ddeeb8ba66f9927f58b684dc8b5">More...</a><br /></td></tr>
<tr class="separator:abdfc9ddeeb8ba66f9927f58b684dc8b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a7dcf5ebaa5f8f0f1c1149ad505982f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classstd_1_1indexer.html#a677771da29cdc65d7db881149cf4abdc">key_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstd_1_1indexer.html#a1a7dcf5ebaa5f8f0f1c1149ad505982f">key</a> (<a class="el" href="classstd_1_1indexer.html#a59e97f3ead469e9d8d383f8a10f46a56">size_type</a> pos) const</td></tr>
<tr class="memdesc:a1a7dcf5ebaa5f8f0f1c1149ad505982f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access element key/identifier (const overload).  <a href="classstd_1_1indexer.html#a1a7dcf5ebaa5f8f0f1c1149ad505982f">More...</a><br /></td></tr>
<tr class="separator:a1a7dcf5ebaa5f8f0f1c1149ad505982f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1edaebfe6db06cea70710eb12d2648d7"><td class="memTemplParams" colspan="2">template&lt;typename OutputContainer &gt; </td></tr>
<tr class="memitem:a1edaebfe6db06cea70710eb12d2648d7"><td class="memTemplItemLeft" align="right" valign="top">OutputContainer&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstd_1_1indexer.html#a1edaebfe6db06cea70710eb12d2648d7">get_keys</a> () const</td></tr>
<tr class="memdesc:a1edaebfe6db06cea70710eb12d2648d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a list of the ids describing the content of the underlying container.  <a href="classstd_1_1indexer.html#a1edaebfe6db06cea70710eb12d2648d7">More...</a><br /></td></tr>
<tr class="separator:a1edaebfe6db06cea70710eb12d2648d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc79363995e1201900c3e2d4c5cc2c29"><td class="memTemplParams" colspan="2">template&lt;typename InputContainer &gt; </td></tr>
<tr class="memitem:acc79363995e1201900c3e2d4c5cc2c29"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstd_1_1indexer.html#acc79363995e1201900c3e2d4c5cc2c29">set_keys</a> (const InputContainer &amp;id)</td></tr>
<tr class="memdesc:acc79363995e1201900c3e2d4c5cc2c29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set key/identifiers into container elements.  <a href="classstd_1_1indexer.html#acc79363995e1201900c3e2d4c5cc2c29">More...</a><br /></td></tr>
<tr class="separator:acc79363995e1201900c3e2d4c5cc2c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0485f55eeabad823c7b04ed3041ba1ff"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstd_1_1indexer.html#a0485f55eeabad823c7b04ed3041ba1ff">empty</a> () const noexcept</td></tr>
<tr class="memdesc:a0485f55eeabad823c7b04ed3041ba1ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if container is empty.  <a href="classstd_1_1indexer.html#a0485f55eeabad823c7b04ed3041ba1ff">More...</a><br /></td></tr>
<tr class="separator:a0485f55eeabad823c7b04ed3041ba1ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b7eda6fff717701d1c35a85641700f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1indexer.html#a59e97f3ead469e9d8d383f8a10f46a56">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstd_1_1indexer.html#a7b7eda6fff717701d1c35a85641700f3">size</a> () const noexcept</td></tr>
<tr class="memdesc:a7b7eda6fff717701d1c35a85641700f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of elements in the underlying container.  <a href="classstd_1_1indexer.html#a7b7eda6fff717701d1c35a85641700f3">More...</a><br /></td></tr>
<tr class="separator:a7b7eda6fff717701d1c35a85641700f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f7aa1e601161184638e428752e16306"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1indexer.html#a59e97f3ead469e9d8d383f8a10f46a56">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstd_1_1indexer.html#a8f7aa1e601161184638e428752e16306">max_size</a> () const noexcept</td></tr>
<tr class="memdesc:a8f7aa1e601161184638e428752e16306"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of elements in the underlying container.  <a href="classstd_1_1indexer.html#a8f7aa1e601161184638e428752e16306">More...</a><br /></td></tr>
<tr class="separator:a8f7aa1e601161184638e428752e16306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43f4a833351e90afb93cb8e9c5b5599f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstd_1_1indexer.html#a43f4a833351e90afb93cb8e9c5b5599f">clear</a> () noexcept</td></tr>
<tr class="memdesc:a43f4a833351e90afb93cb8e9c5b5599f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the contents of the underlying container.  <a href="classstd_1_1indexer.html#a43f4a833351e90afb93cb8e9c5b5599f">More...</a><br /></td></tr>
<tr class="separator:a43f4a833351e90afb93cb8e9c5b5599f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1af166e35dbce8fa4b56b8b30144a045"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1indexer.html#ab561f176e9d82a674e186ff6e33ee81f">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstd_1_1indexer.html#a1af166e35dbce8fa4b56b8b30144a045">begin</a> () noexcept</td></tr>
<tr class="memdesc:a1af166e35dbce8fa4b56b8b30144a045"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to the beginning.  <a href="classstd_1_1indexer.html#a1af166e35dbce8fa4b56b8b30144a045">More...</a><br /></td></tr>
<tr class="separator:a1af166e35dbce8fa4b56b8b30144a045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59044e9e311ac2959367760233be8808"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1indexer.html#ab561f176e9d82a674e186ff6e33ee81f">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstd_1_1indexer.html#a59044e9e311ac2959367760233be8808">end</a> () noexcept</td></tr>
<tr class="memdesc:a59044e9e311ac2959367760233be8808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to the end.  <a href="classstd_1_1indexer.html#a59044e9e311ac2959367760233be8808">More...</a><br /></td></tr>
<tr class="separator:a59044e9e311ac2959367760233be8808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad89f604f648272b8d61e93dcd24d2f87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1indexer.html#a1d435d880c6fed943652f1fb924b6338">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstd_1_1indexer.html#ad89f604f648272b8d61e93dcd24d2f87">begin</a> () const noexcept</td></tr>
<tr class="memdesc:ad89f604f648272b8d61e93dcd24d2f87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to the beginning (const overload).  <a href="classstd_1_1indexer.html#ad89f604f648272b8d61e93dcd24d2f87">More...</a><br /></td></tr>
<tr class="separator:ad89f604f648272b8d61e93dcd24d2f87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34463a60ff759a5309d92d2ab2ffb8d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1indexer.html#a1d435d880c6fed943652f1fb924b6338">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstd_1_1indexer.html#a34463a60ff759a5309d92d2ab2ffb8d9">end</a> () const noexcept</td></tr>
<tr class="memdesc:a34463a60ff759a5309d92d2ab2ffb8d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to the end (const overload).  <a href="classstd_1_1indexer.html#a34463a60ff759a5309d92d2ab2ffb8d9">More...</a><br /></td></tr>
<tr class="separator:a34463a60ff759a5309d92d2ab2ffb8d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a618fa6dc8e2f4a8fe18e302390b3c8e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1indexer.html#a1d435d880c6fed943652f1fb924b6338">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstd_1_1indexer.html#a618fa6dc8e2f4a8fe18e302390b3c8e3">cbegin</a> () const noexcept</td></tr>
<tr class="memdesc:a618fa6dc8e2f4a8fe18e302390b3c8e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an const iterator to the beginning.  <a href="classstd_1_1indexer.html#a618fa6dc8e2f4a8fe18e302390b3c8e3">More...</a><br /></td></tr>
<tr class="separator:a618fa6dc8e2f4a8fe18e302390b3c8e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c4fc5265b22bde81be5e6fdbc4d3663"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1indexer.html#a1d435d880c6fed943652f1fb924b6338">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstd_1_1indexer.html#a9c4fc5265b22bde81be5e6fdbc4d3663">cend</a> () const noexcept</td></tr>
<tr class="memdesc:a9c4fc5265b22bde81be5e6fdbc4d3663"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an const iterator to the end.  <a href="classstd_1_1indexer.html#a9c4fc5265b22bde81be5e6fdbc4d3663">More...</a><br /></td></tr>
<tr class="separator:a9c4fc5265b22bde81be5e6fdbc4d3663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcae7721f0e6fd9404633568ca924615"><td class="memItemLeft" align="right" valign="top">Container &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstd_1_1indexer.html#adcae7721f0e6fd9404633568ca924615">elements</a> () noexcept</td></tr>
<tr class="memdesc:adcae7721f0e6fd9404633568ca924615"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to the underlying container.  <a href="classstd_1_1indexer.html#adcae7721f0e6fd9404633568ca924615">More...</a><br /></td></tr>
<tr class="separator:adcae7721f0e6fd9404633568ca924615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc11cb0b59cd1b88c2d605e5a82e7e61"><td class="memItemLeft" align="right" valign="top">const Container &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstd_1_1indexer.html#abc11cb0b59cd1b88c2d605e5a82e7e61">elements</a> () const noexcept</td></tr>
<tr class="memdesc:abc11cb0b59cd1b88c2d605e5a82e7e61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to the underlying container (const overload).  <a href="classstd_1_1indexer.html#abc11cb0b59cd1b88c2d605e5a82e7e61">More...</a><br /></td></tr>
<tr class="separator:abc11cb0b59cd1b88c2d605e5a82e7e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6db8b4e2cd3f9e1229e56199d9570e8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1indexer.html#af19cd09a80a82ecba0b08482703c478f">element_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstd_1_1indexer.html#a6db8b4e2cd3f9e1229e56199d9570e8e">element</a> (<a class="el" href="classstd_1_1indexer.html#a59e97f3ead469e9d8d383f8a10f46a56">size_type</a> pos)</td></tr>
<tr class="memdesc:a6db8b4e2cd3f9e1229e56199d9570e8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to element at given position. Bypasses public type interface to access underlying indexable/descriptor type.  <a href="classstd_1_1indexer.html#a6db8b4e2cd3f9e1229e56199d9570e8e">More...</a><br /></td></tr>
<tr class="separator:a6db8b4e2cd3f9e1229e56199d9570e8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62d0f3b0af0bbf5fc329b401ef45fc60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1indexer.html#a2b21e6a5992ff589b9a17a95f58f89f3">element_const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstd_1_1indexer.html#a62d0f3b0af0bbf5fc329b401ef45fc60">element</a> (<a class="el" href="classstd_1_1indexer.html#a59e97f3ead469e9d8d383f8a10f46a56">size_type</a> pos) const</td></tr>
<tr class="memdesc:a62d0f3b0af0bbf5fc329b401ef45fc60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const reference to element at given position. Bypasses public type interface to access underlying indexable/descriptor type.  <a href="classstd_1_1indexer.html#a62d0f3b0af0bbf5fc329b401ef45fc60">More...</a><br /></td></tr>
<tr class="separator:a62d0f3b0af0bbf5fc329b401ef45fc60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac91bf80a4c7718b72e71df5428f8a27"><td class="memTemplParams" colspan="2">template&lt;bool oLocked&gt; </td></tr>
<tr class="memitem:aac91bf80a4c7718b72e71df5428f8a27"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstd_1_1indexer.html#aac91bf80a4c7718b72e71df5428f8a27">swap</a> (const <a class="el" href="classstd_1_1indexer.html">indexer</a>&lt; Container, T, oLocked &gt; &amp;other) noexcept</td></tr>
<tr class="memdesc:aac91bf80a4c7718b72e71df5428f8a27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of the underlying container.  <a href="classstd_1_1indexer.html#aac91bf80a4c7718b72e71df5428f8a27">More...</a><br /></td></tr>
<tr class="separator:aac91bf80a4c7718b72e71df5428f8a27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab373018d11fc97014ca38a54cf0bb53"><td class="memItemLeft" align="right" valign="top"><a id="aab373018d11fc97014ca38a54cf0bb53" name="aab373018d11fc97014ca38a54cf0bb53"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>assign</b> (<a class="el" href="classstd_1_1indexer.html#a59e97f3ead469e9d8d383f8a10f46a56">size_type</a> count, const T &amp;value)</td></tr>
<tr class="separator:aab373018d11fc97014ca38a54cf0bb53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a857c3d0f5d3e757a4348c43582a441e7"><td class="memTemplParams" colspan="2"><a id="a857c3d0f5d3e757a4348c43582a441e7" name="a857c3d0f5d3e757a4348c43582a441e7"></a>
template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:a857c3d0f5d3e757a4348c43582a441e7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>assign</b> (InputIt first, InputIt last)</td></tr>
<tr class="separator:a857c3d0f5d3e757a4348c43582a441e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae03dd73d847877bc30db1ba6e18a0baf"><td class="memItemLeft" align="right" valign="top"><a id="ae03dd73d847877bc30db1ba6e18a0baf" name="ae03dd73d847877bc30db1ba6e18a0baf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>assign</b> (std::initializer_list&lt; T &gt; ilist)</td></tr>
<tr class="separator:ae03dd73d847877bc30db1ba6e18a0baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82dcd5bc0a72360f38c640372bde9bc4"><td class="memTemplParams" colspan="2"><a id="a82dcd5bc0a72360f38c640372bde9bc4" name="a82dcd5bc0a72360f38c640372bde9bc4"></a>
template&lt;typename InputIt , typename  = typename enable_if&lt; is_convertible&lt; InputIt, typename container_type::iterator &gt;::value &gt;::type, typename U  = T, typename... Args, typename  = typename enable_if&lt; is_constructible&lt; U, Args... &gt;::value &gt;::type&gt; </td></tr>
<tr class="memitem:a82dcd5bc0a72360f38c640372bde9bc4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>emplace</b> (InputIt pos, Args... args)</td></tr>
<tr class="separator:a82dcd5bc0a72360f38c640372bde9bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9df8923ceec749eed139105e78ea30c5"><td class="memTemplParams" colspan="2"><a id="a9df8923ceec749eed139105e78ea30c5" name="a9df8923ceec749eed139105e78ea30c5"></a>
template&lt;class InputIt , typename  = typename enable_if&lt; is_convertible&lt; InputIt, typename container_type::iterator &gt;::value &gt;::type&gt; </td></tr>
<tr class="memitem:a9df8923ceec749eed139105e78ea30c5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert</b> (InputIt pos, const T &amp;value)</td></tr>
<tr class="separator:a9df8923ceec749eed139105e78ea30c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64f8024aa27f47e2bc9d302c2d7dc83e"><td class="memTemplParams" colspan="2"><a id="a64f8024aa27f47e2bc9d302c2d7dc83e" name="a64f8024aa27f47e2bc9d302c2d7dc83e"></a>
template&lt;class InputIt , typename  = typename enable_if&lt; is_convertible&lt; InputIt, typename container_type::iterator &gt;::value &gt;::type&gt; </td></tr>
<tr class="memitem:a64f8024aa27f47e2bc9d302c2d7dc83e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert</b> (InputIt pos, T &amp;&amp;value)</td></tr>
<tr class="separator:a64f8024aa27f47e2bc9d302c2d7dc83e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be1140fd72bb2f615591514ddb09e2c"><td class="memTemplParams" colspan="2"><a id="a8be1140fd72bb2f615591514ddb09e2c" name="a8be1140fd72bb2f615591514ddb09e2c"></a>
template&lt;class InputIt , typename  = typename enable_if&lt; is_convertible&lt; InputIt, typename container_type::iterator &gt;::value &gt;::type&gt; </td></tr>
<tr class="memitem:a8be1140fd72bb2f615591514ddb09e2c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert</b> (InputIt pos, <a class="el" href="classstd_1_1indexer.html#a59e97f3ead469e9d8d383f8a10f46a56">size_type</a> count, const T &amp;value)</td></tr>
<tr class="separator:a8be1140fd72bb2f615591514ddb09e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b4bfb6167c3d59f02c316251b2c3b50"><td class="memTemplParams" colspan="2"><a id="a8b4bfb6167c3d59f02c316251b2c3b50" name="a8b4bfb6167c3d59f02c316251b2c3b50"></a>
template&lt;typename InputIt , typename SourceIt , typename  = typename enable_if&lt; is_convertible&lt; InputIt, typename container_type::iterator &gt;::value &gt;::type&gt; </td></tr>
<tr class="memitem:a8b4bfb6167c3d59f02c316251b2c3b50"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert</b> (InputIt pos, SourceIt first, SourceIt last)</td></tr>
<tr class="separator:a8b4bfb6167c3d59f02c316251b2c3b50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8566713cfb8191c11f2206185dd3aa0"><td class="memTemplParams" colspan="2"><a id="ac8566713cfb8191c11f2206185dd3aa0" name="ac8566713cfb8191c11f2206185dd3aa0"></a>
template&lt;class InputIt , typename  = typename enable_if&lt; is_convertible&lt; InputIt, typename container_type::iterator &gt;::value &gt;::type&gt; </td></tr>
<tr class="memitem:ac8566713cfb8191c11f2206185dd3aa0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert</b> (InputIt pos, std::initializer_list&lt; T &gt; ilist)</td></tr>
<tr class="separator:ac8566713cfb8191c11f2206185dd3aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90231ed9d82f2df1af3a8b1375d15fd8"><td class="memTemplParams" colspan="2">template&lt;class InputIt , typename  = typename enable_if&lt; is_convertible&lt; InputIt, typename container_type::iterator &gt;::value &gt;::type&gt; </td></tr>
<tr class="memitem:a90231ed9d82f2df1af3a8b1375d15fd8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstd_1_1indexer.html#a90231ed9d82f2df1af3a8b1375d15fd8">erase</a> (InputIt pos)</td></tr>
<tr class="memdesc:a90231ed9d82f2df1af3a8b1375d15fd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases element @ given <em>pos</em>.  <a href="classstd_1_1indexer.html#a90231ed9d82f2df1af3a8b1375d15fd8">More...</a><br /></td></tr>
<tr class="separator:a90231ed9d82f2df1af3a8b1375d15fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d5e9f1b86978ccf6ce77bf5c09be68f"><td class="memTemplParams" colspan="2">template&lt;class InputIt , typename  = typename enable_if&lt; is_convertible&lt; InputIt, typename container_type::iterator &gt;::value &gt;::type&gt; </td></tr>
<tr class="memitem:a9d5e9f1b86978ccf6ce77bf5c09be68f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstd_1_1indexer.html#a9d5e9f1b86978ccf6ce77bf5c09be68f">erase</a> (InputIt first, InputIt last)</td></tr>
<tr class="memdesc:a9d5e9f1b86978ccf6ce77bf5c09be68f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases elements @ range between <em>first</em> and <em>last</em>.  <a href="classstd_1_1indexer.html#a9d5e9f1b86978ccf6ce77bf5c09be68f">More...</a><br /></td></tr>
<tr class="separator:a9d5e9f1b86978ccf6ce77bf5c09be68f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab41b36dd8e552ecf2cd320e61d18dc4e"><td class="memTemplParams" colspan="2">template&lt;typename oT  = value_type, typename C  = Container, typename  = typename enable_if&lt; has_front&lt; C &gt;() &gt;::type&gt; </td></tr>
<tr class="memitem:ab41b36dd8e552ecf2cd320e61d18dc4e"><td class="memTemplItemLeft" align="right" valign="top">oT &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstd_1_1indexer.html#ab41b36dd8e552ecf2cd320e61d18dc4e">front</a> ()</td></tr>
<tr class="memdesc:ab41b36dd8e552ecf2cd320e61d18dc4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access first element in container.  <a href="classstd_1_1indexer.html#ab41b36dd8e552ecf2cd320e61d18dc4e">More...</a><br /></td></tr>
<tr class="separator:ab41b36dd8e552ecf2cd320e61d18dc4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afde710c23c69b3859f93ea61282088b0"><td class="memTemplParams" colspan="2">template&lt;typename oT  = value_type, typename C  = Container, typename  = typename enable_if&lt; has_front&lt; C &gt;() &gt;::type&gt; </td></tr>
<tr class="memitem:afde710c23c69b3859f93ea61282088b0"><td class="memTemplItemLeft" align="right" valign="top">const oT &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstd_1_1indexer.html#afde710c23c69b3859f93ea61282088b0">front</a> () const</td></tr>
<tr class="memdesc:afde710c23c69b3859f93ea61282088b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access first element in container.  <a href="classstd_1_1indexer.html#afde710c23c69b3859f93ea61282088b0">More...</a><br /></td></tr>
<tr class="separator:afde710c23c69b3859f93ea61282088b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae37e049188ad94b38aed10756bd9de48"><td class="memTemplParams" colspan="2">template&lt;typename oT  = value_type, typename C  = Container, typename  = typename enable_if&lt; has_back&lt; C &gt;() &gt;::type&gt; </td></tr>
<tr class="memitem:ae37e049188ad94b38aed10756bd9de48"><td class="memTemplItemLeft" align="right" valign="top">oT &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstd_1_1indexer.html#ae37e049188ad94b38aed10756bd9de48">back</a> ()</td></tr>
<tr class="memdesc:ae37e049188ad94b38aed10756bd9de48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access last element in container.  <a href="classstd_1_1indexer.html#ae37e049188ad94b38aed10756bd9de48">More...</a><br /></td></tr>
<tr class="separator:ae37e049188ad94b38aed10756bd9de48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa328b03b94c2c2d2b60ebc3e740df172"><td class="memTemplParams" colspan="2">template&lt;typename oT  = value_type, typename C  = Container, typename  = typename enable_if&lt; has_back&lt; C &gt;() &gt;::type&gt; </td></tr>
<tr class="memitem:aa328b03b94c2c2d2b60ebc3e740df172"><td class="memTemplItemLeft" align="right" valign="top">const oT &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstd_1_1indexer.html#aa328b03b94c2c2d2b60ebc3e740df172">back</a> () const</td></tr>
<tr class="memdesc:aa328b03b94c2c2d2b60ebc3e740df172"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access last element in container.  <a href="classstd_1_1indexer.html#aa328b03b94c2c2d2b60ebc3e740df172">More...</a><br /></td></tr>
<tr class="separator:aa328b03b94c2c2d2b60ebc3e740df172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b7b7c46b8a066b633fcf29d3ec46846"><td class="memTemplParams" colspan="2">template&lt;typename C  = Container, typename  = typename enable_if&lt; is_front_emplaceable&lt; C &gt;() &gt;::type, typename U  = T, typename... Args, typename  = typename enable_if&lt; is_constructible&lt; U, Args... &gt;::value &gt;::type&gt; </td></tr>
<tr class="memitem:a9b7b7c46b8a066b633fcf29d3ec46846"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstd_1_1indexer.html#a9b7b7c46b8a066b633fcf29d3ec46846">emplace_front</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a9b7b7c46b8a066b633fcf29d3ec46846"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new element in-place @ front of container.  <a href="classstd_1_1indexer.html#a9b7b7c46b8a066b633fcf29d3ec46846">More...</a><br /></td></tr>
<tr class="separator:a9b7b7c46b8a066b633fcf29d3ec46846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4ee239d5cf970955838bff73e3ff97e"><td class="memTemplParams" colspan="2">template&lt;typename C  = Container, typename  = typename enable_if&lt; is_front_emplaceable&lt; C &gt;() &gt;::type, typename U  = T, typename... Args, typename  = typename enable_if&lt; is_constructible&lt; U, Args... &gt;::value &gt;::type&gt; </td></tr>
<tr class="memitem:ae4ee239d5cf970955838bff73e3ff97e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstd_1_1indexer.html#ae4ee239d5cf970955838bff73e3ff97e">emplace_front</a> (const <a class="el" href="classstd_1_1indexer.html#a677771da29cdc65d7db881149cf4abdc">key_type</a> &amp;<a class="el" href="classstd_1_1indexer.html#abdfc9ddeeb8ba66f9927f58b684dc8b5">key</a>, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ae4ee239d5cf970955838bff73e3ff97e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new element in-place @ front of container, w/ indexer key.  <a href="classstd_1_1indexer.html#ae4ee239d5cf970955838bff73e3ff97e">More...</a><br /></td></tr>
<tr class="separator:ae4ee239d5cf970955838bff73e3ff97e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab777b75368653a305d8624660a4f4281"><td class="memTemplParams" colspan="2">template&lt;typename C  = Container, typename  = typename enable_if&lt; is_back_emplaceable&lt; C &gt;() &gt;::type, typename U  = T, typename... Args, typename  = typename enable_if&lt; is_constructible&lt; U, Args... &gt;::value &gt;::type&gt; </td></tr>
<tr class="memitem:ab777b75368653a305d8624660a4f4281"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstd_1_1indexer.html#ab777b75368653a305d8624660a4f4281">emplace_back</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ab777b75368653a305d8624660a4f4281"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new element in-place @ back of container.  <a href="classstd_1_1indexer.html#ab777b75368653a305d8624660a4f4281">More...</a><br /></td></tr>
<tr class="separator:ab777b75368653a305d8624660a4f4281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b40651e8cd466e3f3e2374da0561adc"><td class="memTemplParams" colspan="2">template&lt;typename C  = Container, typename  = typename enable_if&lt; is_back_emplaceable&lt; C &gt;() &gt;::type, typename U  = T, typename... Args, typename  = typename enable_if&lt; is_constructible&lt; U, Args... &gt;::value &gt;::type&gt; </td></tr>
<tr class="memitem:a5b40651e8cd466e3f3e2374da0561adc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstd_1_1indexer.html#a5b40651e8cd466e3f3e2374da0561adc">emplace_back</a> (const <a class="el" href="classstd_1_1indexer.html#a677771da29cdc65d7db881149cf4abdc">key_type</a> &amp;<a class="el" href="classstd_1_1indexer.html#abdfc9ddeeb8ba66f9927f58b684dc8b5">key</a>, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a5b40651e8cd466e3f3e2374da0561adc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new element in-place @ back of container, w/ indexer key.  <a href="classstd_1_1indexer.html#a5b40651e8cd466e3f3e2374da0561adc">More...</a><br /></td></tr>
<tr class="separator:a5b40651e8cd466e3f3e2374da0561adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84386d648c8188094902e5b3a29386a5"><td class="memTemplParams" colspan="2">template&lt;typename C  = Container, typename  = typename enable_if&lt; is_front_pushable&lt; C &gt;() &gt;::type&gt; </td></tr>
<tr class="memitem:a84386d648c8188094902e5b3a29386a5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstd_1_1indexer.html#a84386d648c8188094902e5b3a29386a5">push_front</a> (<a class="el" href="classstd_1_1indexer.html#ae759f8b0b7df8e5e56c8498f66a59dcd">value_type</a> &amp;&amp;value)</td></tr>
<tr class="memdesc:a84386d648c8188094902e5b3a29386a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies given <em>value</em> to @ front of container.  <a href="classstd_1_1indexer.html#a84386d648c8188094902e5b3a29386a5">More...</a><br /></td></tr>
<tr class="separator:a84386d648c8188094902e5b3a29386a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45b6554351c109a0cd5db5ddb27ec6c0"><td class="memTemplParams" colspan="2">template&lt;typename C  = Container, typename  = typename enable_if&lt; is_front_pushable&lt; C &gt;() &gt;::type&gt; </td></tr>
<tr class="memitem:a45b6554351c109a0cd5db5ddb27ec6c0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstd_1_1indexer.html#a45b6554351c109a0cd5db5ddb27ec6c0">push_front</a> (const <a class="el" href="classstd_1_1indexer.html#a677771da29cdc65d7db881149cf4abdc">key_type</a> &amp;<a class="el" href="classstd_1_1indexer.html#abdfc9ddeeb8ba66f9927f58b684dc8b5">key</a>, <a class="el" href="classstd_1_1indexer.html#ae759f8b0b7df8e5e56c8498f66a59dcd">value_type</a> &amp;&amp;value)</td></tr>
<tr class="memdesc:a45b6554351c109a0cd5db5ddb27ec6c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies given <em>value</em> to @ front of container, w/ indexer key.  <a href="classstd_1_1indexer.html#a45b6554351c109a0cd5db5ddb27ec6c0">More...</a><br /></td></tr>
<tr class="separator:a45b6554351c109a0cd5db5ddb27ec6c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa43a897cfe36b14e5e8c2648fd05e442"><td class="memTemplParams" colspan="2">template&lt;typename C  = Container, typename  = typename enable_if&lt; is_back_pushable&lt; C &gt;() &gt;::type&gt; </td></tr>
<tr class="memitem:aa43a897cfe36b14e5e8c2648fd05e442"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstd_1_1indexer.html#aa43a897cfe36b14e5e8c2648fd05e442">push_back</a> (<a class="el" href="classstd_1_1indexer.html#ae759f8b0b7df8e5e56c8498f66a59dcd">value_type</a> &amp;&amp;value)</td></tr>
<tr class="memdesc:aa43a897cfe36b14e5e8c2648fd05e442"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies given <em>value</em> to @ back of container.  <a href="classstd_1_1indexer.html#aa43a897cfe36b14e5e8c2648fd05e442">More...</a><br /></td></tr>
<tr class="separator:aa43a897cfe36b14e5e8c2648fd05e442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eab86512b13bbb46c54d45e8988d55c"><td class="memTemplParams" colspan="2">template&lt;typename C  = Container, typename  = typename enable_if&lt; is_back_pushable&lt; C &gt;() &gt;::type&gt; </td></tr>
<tr class="memitem:a2eab86512b13bbb46c54d45e8988d55c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstd_1_1indexer.html#a2eab86512b13bbb46c54d45e8988d55c">push_back</a> (const <a class="el" href="classstd_1_1indexer.html#a677771da29cdc65d7db881149cf4abdc">key_type</a> &amp;<a class="el" href="classstd_1_1indexer.html#abdfc9ddeeb8ba66f9927f58b684dc8b5">key</a>, <a class="el" href="classstd_1_1indexer.html#ae759f8b0b7df8e5e56c8498f66a59dcd">value_type</a> &amp;&amp;value)</td></tr>
<tr class="memdesc:a2eab86512b13bbb46c54d45e8988d55c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies given <em>value</em> to @ back of container, w/ indexer key.  <a href="classstd_1_1indexer.html#a2eab86512b13bbb46c54d45e8988d55c">More...</a><br /></td></tr>
<tr class="separator:a2eab86512b13bbb46c54d45e8988d55c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91dfc0949cf5b1aae7da146ec14ff3b0"><td class="memTemplParams" colspan="2"><a id="a91dfc0949cf5b1aae7da146ec14ff3b0" name="a91dfc0949cf5b1aae7da146ec14ff3b0"></a>
template&lt;typename C  = Container, typename  = typename enable_if&lt; is_front_poppable&lt; C &gt;() &gt;::type&gt; </td></tr>
<tr class="memitem:a91dfc0949cf5b1aae7da146ec14ff3b0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>pop_front</b> ()</td></tr>
<tr class="memdesc:a91dfc0949cf5b1aae7da146ec14ff3b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes/destroys element @ front of container. <br /></td></tr>
<tr class="separator:a91dfc0949cf5b1aae7da146ec14ff3b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20e5877846fc01256bdc56a469590013"><td class="memTemplParams" colspan="2"><a id="a20e5877846fc01256bdc56a469590013" name="a20e5877846fc01256bdc56a469590013"></a>
template&lt;typename C  = Container, typename  = typename enable_if&lt; is_back_poppable&lt; C &gt;() &gt;::type&gt; </td></tr>
<tr class="memitem:a20e5877846fc01256bdc56a469590013"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>pop_back</b> ()</td></tr>
<tr class="memdesc:a20e5877846fc01256bdc56a469590013"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes/destroys element @ back of container. <br /></td></tr>
<tr class="separator:a20e5877846fc01256bdc56a469590013"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a9ac6f1d456dbee05bfa6e88a614d5801"><td class="memItemLeft" align="right" valign="top"><a id="a9ac6f1d456dbee05bfa6e88a614d5801" name="a9ac6f1d456dbee05bfa6e88a614d5801"></a>
Container&#160;</td><td class="memItemRight" valign="bottom"><b>_data</b></td></tr>
<tr class="memdesc:a9ac6f1d456dbee05bfa6e88a614d5801"><td class="mdescLeft">&#160;</td><td class="mdescRight">Underlying data container. <br /></td></tr>
<tr class="separator:a9ac6f1d456dbee05bfa6e88a614d5801"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename Container, typename T = typename Container::value_type, bool Locked = false&gt;<br />
class std::indexer&lt; Container, T, Locked &gt;</div><p >Simple extensible generic container adapter that provides high-level indexing/key functionality to <em>Container</em>, while maintaining a customizable public interface of a container of <em>T</em>, in line with STL's <em>SequenceContainer</em> named requirements. Represents a pseudo-container type for specialized "indexable" data types i.e. with a public identifier <em>key</em> member. Provides associative features of std::set and std::map in sequence containers (std::array, std::vector, std::deque and std::list), leveraging perfomance advantages of these types. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>Generic container of key/tagged type instances. Must fit STL's Container &amp; SequenceContainer (partial) requirements. </td></tr>
    <tr><td class="paramname">T</td><td>Public/interface type. </td></tr>
    <tr><td class="paramname">Locked</td><td>Whether runtime size manipulation is allowed after initialization. Useful when size of the container does not change but elements do.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Container element type must be a 'key' type that has a public 'id' member with identifier object (asserted @ compile time).</dd>
<dd>
Provides a minimal key/identifier interface, while exposing only a subset of container modifiers for a more generic scope.</dd>
<dd>
Designed to match public interface of other container adapters in the STL (std::stack, std::queue, etc), while also fitting Container requirements (<a href="https://en.cppreference.com/w/cpp/named_req/Container">https://en.cppreference.com/w/cpp/named_req/Container</a>) and partially SequenceContainer, by wrapping around underlying container.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>Rename to indexed_list? </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a1d435d880c6fed943652f1fb924b6338" name="a1d435d880c6fed943652f1fb924b6338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d435d880c6fed943652f1fb924b6338">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename T  = typename Container::value_type, bool Locked = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classstd_1_1indexer.html">std::indexer</a>&lt; Container, T, Locked &gt;::const_iterator =  <a class="el" href="classstd_1_1cast__iterator.html">cast_iterator</a>&lt; const Container, const T &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Const iterator type. Provided to fit with STL 'Container' requirements. </p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classstd_1_1cast__iterator.html" title="Generic class describing a random access bidirectional iterator, with different container and derefer...">cast_iterator</a> auto-converts container elements to different data type on dereferencing operation. </dd></dl>

</div>
</div>
<a id="ab561f176e9d82a674e186ff6e33ee81f" name="ab561f176e9d82a674e186ff6e33ee81f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab561f176e9d82a674e186ff6e33ee81f">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename T  = typename Container::value_type, bool Locked = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classstd_1_1indexer.html">std::indexer</a>&lt; Container, T, Locked &gt;::iterator =  <a class="el" href="classstd_1_1cast__iterator.html">cast_iterator</a>&lt; Container, T &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator type. Provided to fit with STL 'Container' requirements. </p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classstd_1_1cast__iterator.html" title="Generic class describing a random access bidirectional iterator, with different container and derefer...">cast_iterator</a> auto-converts container elements to different data type on dereferencing operation. </dd></dl>

</div>
</div>
<a id="ae759f8b0b7df8e5e56c8498f66a59dcd" name="ae759f8b0b7df8e5e56c8498f66a59dcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae759f8b0b7df8e5e56c8498f66a59dcd">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename T  = typename Container::value_type, bool Locked = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classstd_1_1indexer.html">std::indexer</a>&lt; Container, T, Locked &gt;::value_type =  T</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Static assertions on data types/template arguments. Required in order to avoid ill-formed expressions within class definition. </p>
<p >Value key wrapper type (== container value type). Provided to fit with STL 'Container' requirements. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a356d97a5ba7a2ea11fcc8f88373b969c" name="a356d97a5ba7a2ea11fcc8f88373b969c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a356d97a5ba7a2ea11fcc8f88373b969c">&#9670;&nbsp;</a></span>indexer() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename T  = typename Container::value_type, bool Locked = false&gt; </div>
<div class="memtemplate">
template&lt;typename... Args, typename  = typename enable_if&lt; is_constructible&lt; Container, Args... &gt;::value &gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1indexer.html">std::indexer</a>&lt; Container, T, Locked &gt;::indexer </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a new instance, passing the arguments to the Container constructor (Container::Container(...)) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Container constructor arguments.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>Variadic parameter pack describing types of constructor arguments.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Discards the need to explicitly declare default, copy and move constructors, required to meet STL 'Container' requirements.</dd>
<dd>
std::indexer&lt;&gt; makes no assumptions about how <em>element_type</em> is constructed, as such it may not be possible to assign labels @ construction (e.g. if <em>element_type</em> does not allow it, as is the case of std::tagged&lt;&gt;, or if keys are static/const values). This is by design, as that is considered to be the responsability of the underlying indexable type, and out of the scope of the indexer class. The constructor simply redirects its arguments to underlying container constructor, whcih add versatility. Nonetheless, for convenience, <a class="el" href="indexer_8hpp.html#a021c8da8ca2b5d7e0a640de2bf8c1b23" title="Utility constructor that allows inline initialization of an indexer object and its key set.">std::make_indexer&lt;&gt;()</a> named constructor is provided that accepts key list as arguments. </dd></dl>

</div>
</div>
<a id="a4b313b2b516e0084fdbf8677dc1d4c85" name="a4b313b2b516e0084fdbf8677dc1d4c85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b313b2b516e0084fdbf8677dc1d4c85">&#9670;&nbsp;</a></span>indexer() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename T  = typename Container::value_type, bool Locked = false&gt; </div>
<div class="memtemplate">
template&lt;bool oLocked&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1indexer.html">std::indexer</a>&lt; Container, T, Locked &gt;::indexer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstd_1_1indexer.html">indexer</a>&lt; Container, T, oLocked &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a new (copied) instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>Instance to copy/move.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Default copy assignment operator limits input arguments to same template specialization, but it is useful to bypass Locked value. </dd></dl>

</div>
</div>
<a id="a8e35d38c3fabb61c723d1505f6ff588e" name="a8e35d38c3fabb61c723d1505f6ff588e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e35d38c3fabb61c723d1505f6ff588e">&#9670;&nbsp;</a></span>indexer() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename T  = typename Container::value_type, bool Locked = false&gt; </div>
<div class="memtemplate">
template&lt;bool oLocked&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1indexer.html">std::indexer</a>&lt; Container, T, Locked &gt;::indexer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstd_1_1indexer.html">indexer</a>&lt; Container, T, oLocked &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a new (moved) instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>Instance to copy/move.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Default copy assignment operator limits input arguments to same template specialization, but it is useful to bypass Locked value. </dd></dl>

</div>
</div>
<a id="a9c45b3b3fa3f3f7c81ce0295f3d4a6ae" name="a9c45b3b3fa3f3f7c81ce0295f3d4a6ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c45b3b3fa3f3f7c81ce0295f3d4a6ae">&#9670;&nbsp;</a></span>indexer() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename T  = typename Container::value_type, bool Locked = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1indexer.html">std::indexer</a>&lt; Container, T, Locked &gt;::indexer </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a new instance, from a braced initializer list of <em>T</em> elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>List of elements to assign to underlying container.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Useful when <em>T</em> != <em>Container::value_type</em> (public interface different from underltying element type). Generic variadic parameter pack constructor indexer(Args&amp;&amp;...) captures underlaying Container initializer list constructor, but it will notfit if a list of elements of type <em>T</em> is passed. </dd></dl>

</div>
</div>
<a id="a2f0bb9a0aad009349fb9d3a86cc724a4" name="a2f0bb9a0aad009349fb9d3a86cc724a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f0bb9a0aad009349fb9d3a86cc724a4">&#9670;&nbsp;</a></span>~indexer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename T  = typename Container::value_type, bool Locked = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classstd_1_1indexer.html">std::indexer</a>&lt; Container, T, Locked &gt;::~<a class="el" href="classstd_1_1indexer.html">indexer</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys the object. </p>
<dl class="section note"><dt>Note</dt><dd>Marked virtual to allow deriving from indexer class.</dd>
<dd>
Default (implicit) destructor already meets STL 'Container' requirements. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a14e3c9c39df36e6067a26df3d3d6eb03" name="a14e3c9c39df36e6067a26df3d3d6eb03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14e3c9c39df36e6067a26df3d3d6eb03">&#9670;&nbsp;</a></span>at() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename T  = typename Container::value_type, bool Locked = false&gt; </div>
<div class="memtemplate">
template&lt;typename oT  = value_type, typename Arg  = key_type, typename  = typename enable_if&lt; !is_convertible&lt; Arg, size_type &gt;::value &gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">oT &amp; <a class="el" href="classstd_1_1indexer.html">std::indexer</a>&lt; Container, T, Locked &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstd_1_1indexer.html#a677771da29cdc65d7db881149cf4abdc">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access container element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Element key/identifier.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">oT</td><td>Desired output type. Underlying element type <em>must</em> be convertible to this type. </td></tr>
    <tr><td class="paramname">Arg</td><td>Dummy template argument to force SFINAE check over key_type. </td></tr>
    <tr><td class="paramname">&lt;unnamed&gt;</td><td>SFINAE check that auto-disables operator overload if key_type and size_type are implicitely convertible (e.g. numerical keys).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to T instance.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if identifier is not found.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Only available if key_type is not implicitly convertible to size_type, in order to avoid ambiguity. In that case, only <em>position</em> [] operator overloads can be used (STL container interface).</dd>
<dd>
Templated return type allows explictly requesting either value_type or element_type references @ <em>pos</em>. </dd></dl>

</div>
</div>
<a id="aa98fc0b290777197dd753d149bef5e4e" name="aa98fc0b290777197dd753d149bef5e4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa98fc0b290777197dd753d149bef5e4e">&#9670;&nbsp;</a></span>at() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename T  = typename Container::value_type, bool Locked = false&gt; </div>
<div class="memtemplate">
template&lt;typename oT  = value_type, typename Arg  = key_type, typename  = typename enable_if&lt; !is_convertible&lt; Arg, size_type &gt;::value &gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const oT &amp; <a class="el" href="classstd_1_1indexer.html">std::indexer</a>&lt; Container, T, Locked &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstd_1_1indexer.html#a677771da29cdc65d7db881149cf4abdc">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access container element (const overload). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Element key/identifier.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">oT</td><td>Desired output type. Underlying element type <em>must</em> be convertible to this type. </td></tr>
    <tr><td class="paramname">Arg</td><td>Dummy template argument to force SFINAE check over key_type. </td></tr>
    <tr><td class="paramname">&lt;unnamed&gt;</td><td>SFINAE check that auto-disables operator overload if key_type and size_type are implicitely convertible (e.g. numerical keys).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to T instance.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if identifier is not found.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Only available if key_type is not implicitly convertible to size_type, in order to avoid ambiguity. In that case, only <em>position</em> [] operator overloads can be used (STL container interface).</dd>
<dd>
Templated return type allows explictly requesting either value_type or element_type references @ <em>pos</em>. </dd></dl>

</div>
</div>
<a id="a8ed5217ce0360fcc00207cc4b0da4a5a" name="a8ed5217ce0360fcc00207cc4b0da4a5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ed5217ce0360fcc00207cc4b0da4a5a">&#9670;&nbsp;</a></span>at() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename T  = typename Container::value_type, bool Locked = false&gt; </div>
<div class="memtemplate">
template&lt;typename oT  = value_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">oT &amp; <a class="el" href="classstd_1_1indexer.html">std::indexer</a>&lt; Container, T, Locked &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstd_1_1indexer.html#a59e97f3ead469e9d8d383f8a10f46a56">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access container element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>Element position in container.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">oT</td><td>Desired output type. Underlying element type <em>must</em> be convertible to this type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to T instance.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if pos is invalid.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Templated return type allows explictly requesting either value_type or element_type references @ <em>pos</em>. </dd></dl>

</div>
</div>
<a id="a3b5ad9f44d57000afca5cc1822869796" name="a3b5ad9f44d57000afca5cc1822869796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b5ad9f44d57000afca5cc1822869796">&#9670;&nbsp;</a></span>at() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename T  = typename Container::value_type, bool Locked = false&gt; </div>
<div class="memtemplate">
template&lt;typename oT  = value_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const oT &amp; <a class="el" href="classstd_1_1indexer.html">std::indexer</a>&lt; Container, T, Locked &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstd_1_1indexer.html#a59e97f3ead469e9d8d383f8a10f46a56">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access container element (const overload). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>Element position in container.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">oT</td><td>Desired output type. Underlying element type <em>must</em> be convertible to this type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to T instance.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if pos is invalid.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Templated return type allows explictly requesting either value_type or element_type references @ <em>pos</em>. </dd></dl>

</div>
</div>
<a id="ae37e049188ad94b38aed10756bd9de48" name="ae37e049188ad94b38aed10756bd9de48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae37e049188ad94b38aed10756bd9de48">&#9670;&nbsp;</a></span>back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename T  = typename Container::value_type, bool Locked = false&gt; </div>
<div class="memtemplate">
template&lt;typename oT  = value_type, typename C  = Container, typename  = typename enable_if&lt; has_back&lt; C &gt;() &gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">oT &amp; <a class="el" href="classstd_1_1indexer.html">std::indexer</a>&lt; Container, T, Locked &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access last element in container. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to last element. </dd></dl>

</div>
</div>
<a id="aa328b03b94c2c2d2b60ebc3e740df172" name="aa328b03b94c2c2d2b60ebc3e740df172"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa328b03b94c2c2d2b60ebc3e740df172">&#9670;&nbsp;</a></span>back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename T  = typename Container::value_type, bool Locked = false&gt; </div>
<div class="memtemplate">
template&lt;typename oT  = value_type, typename C  = Container, typename  = typename enable_if&lt; has_back&lt; C &gt;() &gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const oT &amp; <a class="el" href="classstd_1_1indexer.html">std::indexer</a>&lt; Container, T, Locked &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access last element in container. </p>
<dl class="section return"><dt>Returns</dt><dd><em>const</em> reference to last element. </dd></dl>

</div>
</div>
<a id="ad89f604f648272b8d61e93dcd24d2f87" name="ad89f604f648272b8d61e93dcd24d2f87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad89f604f648272b8d61e93dcd24d2f87">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename T  = typename Container::value_type, bool Locked = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1indexer.html#a1d435d880c6fed943652f1fb924b6338">const_iterator</a> <a class="el" href="classstd_1_1indexer.html">std::indexer</a>&lt; Container, T, Locked &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator to the beginning (const overload). </p>
<dl class="section note"><dt>Note</dt><dd>Provided to fit with STL 'Container' requirements. </dd></dl>

</div>
</div>
<a id="a1af166e35dbce8fa4b56b8b30144a045" name="a1af166e35dbce8fa4b56b8b30144a045"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1af166e35dbce8fa4b56b8b30144a045">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename T  = typename Container::value_type, bool Locked = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1indexer.html#ab561f176e9d82a674e186ff6e33ee81f">iterator</a> <a class="el" href="classstd_1_1indexer.html">std::indexer</a>&lt; Container, T, Locked &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator to the beginning. </p>
<dl class="section note"><dt>Note</dt><dd>Provided to fit with STL 'Container' requirements. </dd></dl>

</div>
</div>
<a id="a618fa6dc8e2f4a8fe18e302390b3c8e3" name="a618fa6dc8e2f4a8fe18e302390b3c8e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a618fa6dc8e2f4a8fe18e302390b3c8e3">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename T  = typename Container::value_type, bool Locked = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1indexer.html#a1d435d880c6fed943652f1fb924b6338">const_iterator</a> <a class="el" href="classstd_1_1indexer.html">std::indexer</a>&lt; Container, T, Locked &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an const iterator to the beginning. </p>
<dl class="section note"><dt>Note</dt><dd>Provided to fit with STL 'Container' requirements. </dd></dl>

</div>
</div>
<a id="a9c4fc5265b22bde81be5e6fdbc4d3663" name="a9c4fc5265b22bde81be5e6fdbc4d3663"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c4fc5265b22bde81be5e6fdbc4d3663">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename T  = typename Container::value_type, bool Locked = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1indexer.html#a1d435d880c6fed943652f1fb924b6338">const_iterator</a> <a class="el" href="classstd_1_1indexer.html">std::indexer</a>&lt; Container, T, Locked &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an const iterator to the end. </p>
<dl class="section note"><dt>Note</dt><dd>Provided to fit with STL 'Container' requirements. </dd></dl>

</div>
</div>
<a id="a43f4a833351e90afb93cb8e9c5b5599f" name="a43f4a833351e90afb93cb8e9c5b5599f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43f4a833351e90afb93cb8e9c5b5599f">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename T  = typename Container::value_type, bool Locked = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstd_1_1indexer.html">std::indexer</a>&lt; Container, T, Locked &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the contents of the underlying container. </p>
<dl class="section note"><dt>Note</dt><dd>Only available if Locked is false, otherwise it is not compilable.</dd>
<dd>
Provided to fit with STL 'Container' requirements. </dd></dl>

</div>
</div>
<a id="a6db8b4e2cd3f9e1229e56199d9570e8e" name="a6db8b4e2cd3f9e1229e56199d9570e8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6db8b4e2cd3f9e1229e56199d9570e8e">&#9670;&nbsp;</a></span>element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename T  = typename Container::value_type, bool Locked = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1indexer.html#af19cd09a80a82ecba0b08482703c478f">element_reference</a> <a class="el" href="classstd_1_1indexer.html">std::indexer</a>&lt; Container, T, Locked &gt;::element </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstd_1_1indexer.html#a59e97f3ead469e9d8d383f8a10f46a56">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a reference to element at given position. Bypasses public type interface to access underlying indexable/descriptor type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>Element position in underlying container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a62d0f3b0af0bbf5fc329b401ef45fc60" name="a62d0f3b0af0bbf5fc329b401ef45fc60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62d0f3b0af0bbf5fc329b401ef45fc60">&#9670;&nbsp;</a></span>element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename T  = typename Container::value_type, bool Locked = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1indexer.html#a2b21e6a5992ff589b9a17a95f58f89f3">element_const_reference</a> <a class="el" href="classstd_1_1indexer.html">std::indexer</a>&lt; Container, T, Locked &gt;::element </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstd_1_1indexer.html#a59e97f3ead469e9d8d383f8a10f46a56">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a const reference to element at given position. Bypasses public type interface to access underlying indexable/descriptor type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>Element position in underlying container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abc11cb0b59cd1b88c2d605e5a82e7e61" name="abc11cb0b59cd1b88c2d605e5a82e7e61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc11cb0b59cd1b88c2d605e5a82e7e61">&#9670;&nbsp;</a></span>elements() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename T  = typename Container::value_type, bool Locked = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Container &amp; <a class="el" href="classstd_1_1indexer.html">std::indexer</a>&lt; Container, T, Locked &gt;::elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reference to the underlying container (const overload). </p>
<dl class="section note"><dt>Note</dt><dd>Useful to manage objects directly, in cases where T != Container::value_type (i.e. iterators return different types when dereferencing). </dd></dl>

</div>
</div>
<a id="adcae7721f0e6fd9404633568ca924615" name="adcae7721f0e6fd9404633568ca924615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcae7721f0e6fd9404633568ca924615">&#9670;&nbsp;</a></span>elements() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename T  = typename Container::value_type, bool Locked = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Container &amp; <a class="el" href="classstd_1_1indexer.html">std::indexer</a>&lt; Container, T, Locked &gt;::elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reference to the underlying container. </p>
<dl class="section note"><dt>Note</dt><dd>Useful to manage objects directly, in cases where T != Container::value_type (i.e. iterators return different types when dereferencing). </dd></dl>

</div>
</div>
<a id="ab777b75368653a305d8624660a4f4281" name="ab777b75368653a305d8624660a4f4281"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab777b75368653a305d8624660a4f4281">&#9670;&nbsp;</a></span>emplace_back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename T  = typename Container::value_type, bool Locked = false&gt; </div>
<div class="memtemplate">
template&lt;typename C  = Container, typename  = typename enable_if&lt; is_back_emplaceable&lt; C &gt;() &gt;::type, typename U  = T, typename... Args, typename  = typename enable_if&lt; is_constructible&lt; U, Args... &gt;::value &gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstd_1_1indexer.html">std::indexer</a>&lt; Container, T, Locked &gt;::emplace_back </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new element in-place @ back of container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Arguments passed to the element constructor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>Variadic parameter pack (implicitely deduced) describing type list of constructor arguments. </td></tr>
    <tr><td class="paramname">&lt;unnamed&gt;</td><td>SFINAE check that shadows/disables constructor overload if <em>T</em> can't be constructed with <em>Args</em> i.e. T(Args..) is not declared/defined </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b40651e8cd466e3f3e2374da0561adc" name="a5b40651e8cd466e3f3e2374da0561adc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b40651e8cd466e3f3e2374da0561adc">&#9670;&nbsp;</a></span>emplace_back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename T  = typename Container::value_type, bool Locked = false&gt; </div>
<div class="memtemplate">
template&lt;typename C  = Container, typename  = typename enable_if&lt; is_back_emplaceable&lt; C &gt;() &gt;::type, typename U  = T, typename... Args, typename  = typename enable_if&lt; is_constructible&lt; U, Args... &gt;::value &gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstd_1_1indexer.html">std::indexer</a>&lt; Container, T, Locked &gt;::emplace_back </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstd_1_1indexer.html#a677771da29cdc65d7db881149cf4abdc">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new element in-place @ back of container, w/ indexer key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key to assign to new element. </td></tr>
    <tr><td class="paramname">args</td><td>Arguments passed to the element constructor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>Variadic parameter pack (implicitely deduced) describing type list of constructor arguments. </td></tr>
    <tr><td class="paramname">&lt;unnamed&gt;</td><td>SFINAE check that shadows/disables constructor overload if <em>T</em> can't be constructed with <em>Args</em> i.e. T(Args..) is not declared/defined </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b7b7c46b8a066b633fcf29d3ec46846" name="a9b7b7c46b8a066b633fcf29d3ec46846"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b7b7c46b8a066b633fcf29d3ec46846">&#9670;&nbsp;</a></span>emplace_front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename T  = typename Container::value_type, bool Locked = false&gt; </div>
<div class="memtemplate">
template&lt;typename C  = Container, typename  = typename enable_if&lt; is_front_emplaceable&lt; C &gt;() &gt;::type, typename U  = T, typename... Args, typename  = typename enable_if&lt; is_constructible&lt; U, Args... &gt;::value &gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstd_1_1indexer.html">std::indexer</a>&lt; Container, T, Locked &gt;::emplace_front </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new element in-place @ front of container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Arguments passed to the element constructor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>Variadic parameter pack (implicitely deduced) describing type list of constructor arguments. </td></tr>
    <tr><td class="paramname">&lt;unnamed&gt;</td><td>SFINAE check that shadows/disables constructor overload if <em>T</em> can't be constructed with <em>Args</em> i.e. T(Args..) is not declared/defined </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae4ee239d5cf970955838bff73e3ff97e" name="ae4ee239d5cf970955838bff73e3ff97e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4ee239d5cf970955838bff73e3ff97e">&#9670;&nbsp;</a></span>emplace_front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename T  = typename Container::value_type, bool Locked = false&gt; </div>
<div class="memtemplate">
template&lt;typename C  = Container, typename  = typename enable_if&lt; is_front_emplaceable&lt; C &gt;() &gt;::type, typename U  = T, typename... Args, typename  = typename enable_if&lt; is_constructible&lt; U, Args... &gt;::value &gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstd_1_1indexer.html">std::indexer</a>&lt; Container, T, Locked &gt;::emplace_front </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstd_1_1indexer.html#a677771da29cdc65d7db881149cf4abdc">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new element in-place @ front of container, w/ indexer key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key to assign to new element. </td></tr>
    <tr><td class="paramname">args</td><td>Arguments passed to the element constructor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>Variadic parameter pack (implicitely deduced) describing type list of constructor arguments. </td></tr>
    <tr><td class="paramname">&lt;unnamed&gt;</td><td>SFINAE check that shadows/disables constructor overload if <em>T</em> can't be constructed with <em>Args</em> i.e. T(Args..) is not declared/defined </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0485f55eeabad823c7b04ed3041ba1ff" name="a0485f55eeabad823c7b04ed3041ba1ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0485f55eeabad823c7b04ed3041ba1ff">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename T  = typename Container::value_type, bool Locked = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classstd_1_1indexer.html">std::indexer</a>&lt; Container, T, Locked &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if container is empty. </p>
<dl class="section return"><dt>Returns</dt><dd>True if undelying container is empty, false otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Provided to fit with STL 'Container' requirements. </dd></dl>

</div>
</div>
<a id="a34463a60ff759a5309d92d2ab2ffb8d9" name="a34463a60ff759a5309d92d2ab2ffb8d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34463a60ff759a5309d92d2ab2ffb8d9">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename T  = typename Container::value_type, bool Locked = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1indexer.html#a1d435d880c6fed943652f1fb924b6338">const_iterator</a> <a class="el" href="classstd_1_1indexer.html">std::indexer</a>&lt; Container, T, Locked &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator to the end (const overload). </p>
<dl class="section note"><dt>Note</dt><dd>Provided to fit with STL 'Container' requirements. </dd></dl>

</div>
</div>
<a id="a59044e9e311ac2959367760233be8808" name="a59044e9e311ac2959367760233be8808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59044e9e311ac2959367760233be8808">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename T  = typename Container::value_type, bool Locked = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1indexer.html#ab561f176e9d82a674e186ff6e33ee81f">iterator</a> <a class="el" href="classstd_1_1indexer.html">std::indexer</a>&lt; Container, T, Locked &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator to the end. </p>
<dl class="section note"><dt>Note</dt><dd>Provided to fit with STL 'Container' requirements. </dd></dl>

</div>
</div>
<a id="a9d5e9f1b86978ccf6ce77bf5c09be68f" name="a9d5e9f1b86978ccf6ce77bf5c09be68f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d5e9f1b86978ccf6ce77bf5c09be68f">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename T  = typename Container::value_type, bool Locked = false&gt; </div>
<div class="memtemplate">
template&lt;class InputIt , typename  = typename enable_if&lt; is_convertible&lt; InputIt, typename container_type::iterator &gt;::value &gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstd_1_1indexer.html">std::indexer</a>&lt; Container, T, Locked &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erases elements @ range between <em>first</em> and <em>last</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>Iterator to element to erase.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to first element after <em>pos</em>. </dd></dl>

</div>
</div>
<a id="a90231ed9d82f2df1af3a8b1375d15fd8" name="a90231ed9d82f2df1af3a8b1375d15fd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90231ed9d82f2df1af3a8b1375d15fd8">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename T  = typename Container::value_type, bool Locked = false&gt; </div>
<div class="memtemplate">
template&lt;class InputIt , typename  = typename enable_if&lt; is_convertible&lt; InputIt, typename container_type::iterator &gt;::value &gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstd_1_1indexer.html">std::indexer</a>&lt; Container, T, Locked &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erases element @ given <em>pos</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>Iterator to element to erase. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a56604ec6f2532c9f5ea37ad538132525" name="a56604ec6f2532c9f5ea37ad538132525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56604ec6f2532c9f5ea37ad538132525">&#9670;&nbsp;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename T  = typename Container::value_type, bool Locked = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classstd_1_1indexer.html#a59e97f3ead469e9d8d383f8a10f46a56">size_type</a> <a class="el" href="classstd_1_1indexer.html">std::indexer</a>&lt; Container, T, Locked &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstd_1_1indexer.html#a677771da29cdc65d7db881149cf4abdc">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get element position from its identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>Element key/identifier.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position in container if element is found, -1 otherwise. </dd></dl>

</div>
</div>
<a id="ab41b36dd8e552ecf2cd320e61d18dc4e" name="ab41b36dd8e552ecf2cd320e61d18dc4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab41b36dd8e552ecf2cd320e61d18dc4e">&#9670;&nbsp;</a></span>front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename T  = typename Container::value_type, bool Locked = false&gt; </div>
<div class="memtemplate">
template&lt;typename oT  = value_type, typename C  = Container, typename  = typename enable_if&lt; has_front&lt; C &gt;() &gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">oT &amp; <a class="el" href="classstd_1_1indexer.html">std::indexer</a>&lt; Container, T, Locked &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access first element in container. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to first element. </dd></dl>

</div>
</div>
<a id="afde710c23c69b3859f93ea61282088b0" name="afde710c23c69b3859f93ea61282088b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afde710c23c69b3859f93ea61282088b0">&#9670;&nbsp;</a></span>front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename T  = typename Container::value_type, bool Locked = false&gt; </div>
<div class="memtemplate">
template&lt;typename oT  = value_type, typename C  = Container, typename  = typename enable_if&lt; has_front&lt; C &gt;() &gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const oT &amp; <a class="el" href="classstd_1_1indexer.html">std::indexer</a>&lt; Container, T, Locked &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access first element in container. </p>
<dl class="section return"><dt>Returns</dt><dd><em>const</em> reference to first element. </dd></dl>

</div>
</div>
<a id="a1edaebfe6db06cea70710eb12d2648d7" name="a1edaebfe6db06cea70710eb12d2648d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1edaebfe6db06cea70710eb12d2648d7">&#9670;&nbsp;</a></span>get_keys()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename T  = typename Container::value_type, bool Locked = false&gt; </div>
<div class="memtemplate">
template&lt;typename OutputContainer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputContainer <a class="el" href="classstd_1_1indexer.html">std::indexer</a>&lt; Container, T, Locked &gt;::get_keys </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a list of the ids describing the content of the underlying container. </p>
<dl class="section return"><dt>Returns</dt><dd>Container with id values.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputContainer</td><td>Container type. Must be a SequenceContainer with ::push_back() defined (e.g. std::basic_string, std::deque, std::vector) of type compatible with key_type . </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abdfc9ddeeb8ba66f9927f58b684dc8b5" name="abdfc9ddeeb8ba66f9927f58b684dc8b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdfc9ddeeb8ba66f9927f58b684dc8b5">&#9670;&nbsp;</a></span>key() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename T  = typename Container::value_type, bool Locked = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1indexer.html#a677771da29cdc65d7db881149cf4abdc">key_type</a> &amp; <a class="el" href="classstd_1_1indexer.html">std::indexer</a>&lt; Container, T, Locked &gt;::key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstd_1_1indexer.html#a59e97f3ead469e9d8d383f8a10f46a56">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access element key/identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>Element position in container.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to key object.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if pos is invalid.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Usdeful to set element key/identifiers. </dd></dl>

</div>
</div>
<a id="a1a7dcf5ebaa5f8f0f1c1149ad505982f" name="a1a7dcf5ebaa5f8f0f1c1149ad505982f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a7dcf5ebaa5f8f0f1c1149ad505982f">&#9670;&nbsp;</a></span>key() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename T  = typename Container::value_type, bool Locked = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classstd_1_1indexer.html#a677771da29cdc65d7db881149cf4abdc">key_type</a> &amp; <a class="el" href="classstd_1_1indexer.html">std::indexer</a>&lt; Container, T, Locked &gt;::key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstd_1_1indexer.html#a59e97f3ead469e9d8d383f8a10f46a56">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access element key/identifier (const overload). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>Element position in container.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to key object.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if pos is invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f7aa1e601161184638e428752e16306" name="a8f7aa1e601161184638e428752e16306"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f7aa1e601161184638e428752e16306">&#9670;&nbsp;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename T  = typename Container::value_type, bool Locked = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1indexer.html#a59e97f3ead469e9d8d383f8a10f46a56">size_type</a> <a class="el" href="classstd_1_1indexer.html">std::indexer</a>&lt; Container, T, Locked &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum number of elements in the underlying container. </p>
<dl class="section note"><dt>Note</dt><dd>Provided to fit with STL 'Container' requirements. </dd></dl>

</div>
</div>
<a id="a3aee8e61220c8fb64cc7a3647b991ff8" name="a3aee8e61220c8fb64cc7a3647b991ff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aee8e61220c8fb64cc7a3647b991ff8">&#9670;&nbsp;</a></span>operator()() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename T  = typename Container::value_type, bool Locked = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1indexer.html#ae2db1ee5c5641d5faaef45747c63ac37">reference</a> <a class="el" href="classstd_1_1indexer.html">std::indexer</a>&lt; Container, T, Locked &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstd_1_1indexer.html#a677771da29cdc65d7db881149cf4abdc">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access container element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Element key/identifier.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to T instance.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if identifier is not found. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac4eccd9de572f750b182be285a66b767" name="ac4eccd9de572f750b182be285a66b767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4eccd9de572f750b182be285a66b767">&#9670;&nbsp;</a></span>operator()() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename T  = typename Container::value_type, bool Locked = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1indexer.html#abfaec2da712e26c1c02b7433952f6599">const_reference</a> <a class="el" href="classstd_1_1indexer.html">std::indexer</a>&lt; Container, T, Locked &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstd_1_1indexer.html#a677771da29cdc65d7db881149cf4abdc">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access container element (const overload). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Element key/identifier.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to T instance.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if identifier is not found. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e5fac2a6c305177ba9834949af44dd6" name="a2e5fac2a6c305177ba9834949af44dd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e5fac2a6c305177ba9834949af44dd6">&#9670;&nbsp;</a></span>operator()() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename T  = typename Container::value_type, bool Locked = false&gt; </div>
<div class="memtemplate">
template&lt;typename Arg  = key_type, typename  = typename enable_if&lt; !is_convertible&lt; Arg, size_type &gt;::value &gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1indexer.html#ae2db1ee5c5641d5faaef45747c63ac37">reference</a> <a class="el" href="classstd_1_1indexer.html">std::indexer</a>&lt; Container, T, Locked &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstd_1_1indexer.html#a59e97f3ead469e9d8d383f8a10f46a56">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access container element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>Element position in container.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Arg</td><td>Dummy template argument to force SFINAE check over key_type. </td></tr>
    <tr><td class="paramname">&lt;unnamed&gt;</td><td>SFINAE check that auto-disables operator overload if key_type and size_type are implicitely convertible (e.g. numerical keys).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to T instance.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if pos is invalid.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Only available if key_type is not implicitly convertible to size_type, in order to avoid ambiguity. </dd></dl>

</div>
</div>
<a id="a87e7541c4b7e2bada8f8001eaab88480" name="a87e7541c4b7e2bada8f8001eaab88480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87e7541c4b7e2bada8f8001eaab88480">&#9670;&nbsp;</a></span>operator()() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename T  = typename Container::value_type, bool Locked = false&gt; </div>
<div class="memtemplate">
template&lt;typename Arg  = key_type, typename  = typename enable_if&lt; !is_convertible&lt; Arg, size_type &gt;::value &gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1indexer.html#abfaec2da712e26c1c02b7433952f6599">const_reference</a> <a class="el" href="classstd_1_1indexer.html">std::indexer</a>&lt; Container, T, Locked &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstd_1_1indexer.html#a59e97f3ead469e9d8d383f8a10f46a56">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access container element (const overload). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>Element position in container.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Arg</td><td>Dummy template argument to force SFINAE check over key_type. </td></tr>
    <tr><td class="paramname">&lt;unnamed&gt;</td><td>SFINAE check that auto-disables operator overload if key_type and size_type are implicitely convertible (e.g. numerical keys).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to T instance.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if pos is invalid.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Only available if key_type is not implicitly convertible to size_type, in order to avoid ambiguity. </dd></dl>

</div>
</div>
<a id="aa60b1004706755f1378b22ac5967365a" name="aa60b1004706755f1378b22ac5967365a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa60b1004706755f1378b22ac5967365a">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename T  = typename Container::value_type, bool Locked = false&gt; </div>
<div class="memtemplate">
template&lt;bool oLocked&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1indexer.html">indexer</a>&lt; Container, T, Locked &gt; &amp; <a class="el" href="classstd_1_1indexer.html">std::indexer</a>&lt; Container, T, Locked &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstd_1_1indexer.html">indexer</a>&lt; Container, T, oLocked &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy assignment operator. </p>
<dl class="section note"><dt>Note</dt><dd>Default copy assignment operator limits input arguments to same template specialization, but it is useful to bypass Locked value.</dd>
<dd>
Provided to fit with STL 'Container' requirements. </dd></dl>

</div>
</div>
<a id="aa045218a06b84b97d094362083b5a486" name="aa045218a06b84b97d094362083b5a486"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa045218a06b84b97d094362083b5a486">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename T  = typename Container::value_type, bool Locked = false&gt; </div>
<div class="memtemplate">
template&lt;bool oLocked&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1indexer.html">indexer</a>&lt; Container, T, Locked &gt; &amp; <a class="el" href="classstd_1_1indexer.html">std::indexer</a>&lt; Container, T, Locked &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstd_1_1indexer.html">indexer</a>&lt; Container, T, oLocked &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move assignment operator. </p>
<dl class="section note"><dt>Note</dt><dd>Default move assignment operator limits input arguments to same template specialization, but it is useful to bypass Locked value.</dd>
<dd>
Provided to fit with STL 'Container' requirements. </dd></dl>

</div>
</div>
<a id="a81010896f3babe94a6488fe1d6fbd8cb" name="a81010896f3babe94a6488fe1d6fbd8cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81010896f3babe94a6488fe1d6fbd8cb">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename T  = typename Container::value_type, bool Locked = false&gt; </div>
<div class="memtemplate">
template&lt;typename Arg  = key_type, typename  = typename enable_if&lt; !is_convertible&lt; Arg, size_type &gt;::value &gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1indexer.html#ae2db1ee5c5641d5faaef45747c63ac37">reference</a> <a class="el" href="classstd_1_1indexer.html">std::indexer</a>&lt; Container, T, Locked &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstd_1_1indexer.html#a677771da29cdc65d7db881149cf4abdc">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access container element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Element key/identifier.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Arg</td><td>Dummy template argument to force SFINAE check over key_type. </td></tr>
    <tr><td class="paramname">&lt;unnamed&gt;</td><td>SFINAE check that auto-disables operator overload if key_type and size_type are implicitely convertible (e.g. numerical keys).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to T instance.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if identifier is not found.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Only available if key_type is not implicitly convertible to size_type, in order to avoid ambiguity. In that case, only <em>position</em> [] operator overloads can be used (STL container interface). </dd></dl>

</div>
</div>
<a id="a67dd9c5bddcdd98fe37b0374576799fa" name="a67dd9c5bddcdd98fe37b0374576799fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67dd9c5bddcdd98fe37b0374576799fa">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename T  = typename Container::value_type, bool Locked = false&gt; </div>
<div class="memtemplate">
template&lt;typename Arg  = key_type, typename  = typename enable_if&lt; !is_convertible&lt; Arg, size_type &gt;::value &gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1indexer.html#abfaec2da712e26c1c02b7433952f6599">const_reference</a> <a class="el" href="classstd_1_1indexer.html">std::indexer</a>&lt; Container, T, Locked &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstd_1_1indexer.html#a677771da29cdc65d7db881149cf4abdc">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access container element (const overload). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Element key/identifier.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Arg</td><td>Dummy template argument to force SFINAE check over key_type. </td></tr>
    <tr><td class="paramname">&lt;unnamed&gt;</td><td>SFINAE check that auto-disables operator overload if key_type and size_type are implicitely convertible (e.g. numerical keys).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to T instance.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if identifier is not found.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Only available if key_type is not implicitly convertible to size_type, in order to avoid ambiguity. In that case, only <em>position</em> [] operator overloads can be used (STL container interface). </dd></dl>

</div>
</div>
<a id="a5c85d26bb9699dbdcd146f4b673339cb" name="a5c85d26bb9699dbdcd146f4b673339cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c85d26bb9699dbdcd146f4b673339cb">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename T  = typename Container::value_type, bool Locked = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1indexer.html#ae2db1ee5c5641d5faaef45747c63ac37">reference</a> <a class="el" href="classstd_1_1indexer.html">std::indexer</a>&lt; Container, T, Locked &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstd_1_1indexer.html#a59e97f3ead469e9d8d383f8a10f46a56">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access container element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>Element position in container.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to T instance.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if pos is invalid.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Only available if key_type is not implicitly convertible to size_type, in order to avoid ambiguity. In that case, only <em>key</em> overloads are accepted. </dd></dl>

</div>
</div>
<a id="a0243ac580a0039246757ee371e1ffba3" name="a0243ac580a0039246757ee371e1ffba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0243ac580a0039246757ee371e1ffba3">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename T  = typename Container::value_type, bool Locked = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1indexer.html#abfaec2da712e26c1c02b7433952f6599">const_reference</a> <a class="el" href="classstd_1_1indexer.html">std::indexer</a>&lt; Container, T, Locked &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstd_1_1indexer.html#a59e97f3ead469e9d8d383f8a10f46a56">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access container element (const overload). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>Element position in container.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to T instance.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if pos is invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2eab86512b13bbb46c54d45e8988d55c" name="a2eab86512b13bbb46c54d45e8988d55c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eab86512b13bbb46c54d45e8988d55c">&#9670;&nbsp;</a></span>push_back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename T  = typename Container::value_type, bool Locked = false&gt; </div>
<div class="memtemplate">
template&lt;typename C  = Container, typename  = typename enable_if&lt; is_back_pushable&lt; C &gt;() &gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstd_1_1indexer.html">std::indexer</a>&lt; Container, T, Locked &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstd_1_1indexer.html#a677771da29cdc65d7db881149cf4abdc">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classstd_1_1indexer.html#ae759f8b0b7df8e5e56c8498f66a59dcd">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies given <em>value</em> to @ back of container, w/ indexer key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key to assign to new element. </td></tr>
    <tr><td class="paramname">value</td><td>Value to add to the underlying container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa43a897cfe36b14e5e8c2648fd05e442" name="aa43a897cfe36b14e5e8c2648fd05e442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa43a897cfe36b14e5e8c2648fd05e442">&#9670;&nbsp;</a></span>push_back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename T  = typename Container::value_type, bool Locked = false&gt; </div>
<div class="memtemplate">
template&lt;typename C  = Container, typename  = typename enable_if&lt; is_back_pushable&lt; C &gt;() &gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstd_1_1indexer.html">std::indexer</a>&lt; Container, T, Locked &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstd_1_1indexer.html#ae759f8b0b7df8e5e56c8498f66a59dcd">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies given <em>value</em> to @ back of container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Value to add to the underlying container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a45b6554351c109a0cd5db5ddb27ec6c0" name="a45b6554351c109a0cd5db5ddb27ec6c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45b6554351c109a0cd5db5ddb27ec6c0">&#9670;&nbsp;</a></span>push_front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename T  = typename Container::value_type, bool Locked = false&gt; </div>
<div class="memtemplate">
template&lt;typename C  = Container, typename  = typename enable_if&lt; is_front_pushable&lt; C &gt;() &gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstd_1_1indexer.html">std::indexer</a>&lt; Container, T, Locked &gt;::push_front </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstd_1_1indexer.html#a677771da29cdc65d7db881149cf4abdc">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classstd_1_1indexer.html#ae759f8b0b7df8e5e56c8498f66a59dcd">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies given <em>value</em> to @ front of container, w/ indexer key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key to assign to new element. </td></tr>
    <tr><td class="paramname">value</td><td>Value to add to the underlying container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a84386d648c8188094902e5b3a29386a5" name="a84386d648c8188094902e5b3a29386a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84386d648c8188094902e5b3a29386a5">&#9670;&nbsp;</a></span>push_front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename T  = typename Container::value_type, bool Locked = false&gt; </div>
<div class="memtemplate">
template&lt;typename C  = Container, typename  = typename enable_if&lt; is_front_pushable&lt; C &gt;() &gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstd_1_1indexer.html">std::indexer</a>&lt; Container, T, Locked &gt;::push_front </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstd_1_1indexer.html#ae759f8b0b7df8e5e56c8498f66a59dcd">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies given <em>value</em> to @ front of container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Value to add to the underlying container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc79363995e1201900c3e2d4c5cc2c29" name="acc79363995e1201900c3e2d4c5cc2c29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc79363995e1201900c3e2d4c5cc2c29">&#9670;&nbsp;</a></span>set_keys()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename T  = typename Container::value_type, bool Locked = false&gt; </div>
<div class="memtemplate">
template&lt;typename InputContainer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstd_1_1indexer.html">std::indexer</a>&lt; Container, T, Locked &gt;::set_keys </td>
          <td>(</td>
          <td class="paramtype">const InputContainer &amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set key/identifiers into container elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ids</td><td>Element keys/identifiers</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputContainer</td><td>Container type. Must be compatible with range-based loops (e.g. STL containers), and be of a type compatible </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b7eda6fff717701d1c35a85641700f3" name="a7b7eda6fff717701d1c35a85641700f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b7eda6fff717701d1c35a85641700f3">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename T  = typename Container::value_type, bool Locked = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1indexer.html#a59e97f3ead469e9d8d383f8a10f46a56">size_type</a> <a class="el" href="classstd_1_1indexer.html">std::indexer</a>&lt; Container, T, Locked &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of elements in the underlying container. </p>
<dl class="section note"><dt>Note</dt><dd>Provided to fit with STL 'Container' requirements. </dd></dl>

</div>
</div>
<a id="aac91bf80a4c7718b72e71df5428f8a27" name="aac91bf80a4c7718b72e71df5428f8a27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac91bf80a4c7718b72e71df5428f8a27">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename T  = typename Container::value_type, bool Locked = false&gt; </div>
<div class="memtemplate">
template&lt;bool oLocked&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstd_1_1indexer.html">std::indexer</a>&lt; Container, T, Locked &gt;::swap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstd_1_1indexer.html">indexer</a>&lt; Container, T, oLocked &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of the underlying container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>Other locked/unlocked indexer instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">oLocked</td><td>Lock status of the input indexer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Provided to fit with STL 'Container' requirements. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/joao/Shared/PHD/code/ros/src/storage/include/storage/<a class="el" href="indexer_8hpp_source.html">indexer.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>std</b></li><li class="navelem"><a class="el" href="classstd_1_1indexer.html">indexer</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3 </li>
  </ul>
</div>
</body>
</html>
