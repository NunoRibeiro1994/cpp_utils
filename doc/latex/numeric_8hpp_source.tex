\hypertarget{numeric_8hpp_source}{}\doxysection{numeric.\+hpp}
\label{numeric_8hpp_source}\index{/home/joao/Shared/PHD/code/ros/src/storage/include/storage/numeric.hpp@{/home/joao/Shared/PHD/code/ros/src/storage/include/storage/numeric.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{preprocessor}{\#ifndef \_STORAGE\_NUMERIC\_HPP\_}}
\DoxyCodeLine{2 \textcolor{preprocessor}{\#define \_STORAGE\_NUMERIC\_HPP\_}}
\DoxyCodeLine{4 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{5 \textcolor{preprocessor}{\#include <random>}}
\DoxyCodeLine{6 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{7 \textcolor{preprocessor}{\#include <utility>}}
\DoxyCodeLine{8 \textcolor{preprocessor}{\#include "{}storage/matrix.hpp"{}}}
\DoxyCodeLine{9 }
\DoxyCodeLine{11 \textcolor{comment}{// templated header-\/only functions for numeric operations}}
\DoxyCodeLine{12 \textcolor{comment}{// provides std::matrix bulk and element-\/wise arithmetic operator overloads (+-\//*) and matrix presets (zero,ones,ident,random,etc);}}
\DoxyCodeLine{13 \textcolor{comment}{// provides std::volume bulk and element-\/wise arithmetic operator overloads (+-\//*) and volume presets (zero,ones,ident,random,etc);}}
\DoxyCodeLine{14 \textcolor{comment}{// namespace std::numeric includes sorting algorithms, scalar utility functions (norm,deg2rad,rad2deg,floor,clamp,round,etc)}}
\DoxyCodeLine{15 }
\DoxyCodeLine{16 \textcolor{comment}{// numerical operators between data types are assumed to be defined (or implicit conversion between types);}}
\DoxyCodeLine{17 \textcolor{comment}{// no static assertion is performed, a compilation error will be thrown otherwise anyway;}}
\DoxyCodeLine{20 \textcolor{comment}{}\textcolor{keyword}{namespace }std \{}
\DoxyCodeLine{21 \textcolor{keyword}{namespace }storage \{}
\DoxyCodeLine{22 \textcolor{keyword}{template} <\textcolor{keyword}{typename} lCT>}
\DoxyCodeLine{23 \textcolor{keyword}{using} container\_subset = st\_subset\_base<lCT>;}
\DoxyCodeLine{24 \}  \textcolor{comment}{// namespace storage}}
\DoxyCodeLine{25 \}  \textcolor{comment}{// namespace std}}
\DoxyCodeLine{27 \textcolor{comment}{}\textcolor{comment}{// subset compound operator overloads}}
\DoxyCodeLine{28 \textcolor{comment}{// take rvalue references as arguments in order to 1) be able to modify left operand (vs const\&) and 2) allow in-\/line statements (mat.row()+=5)}}
\DoxyCodeLine{29 \textcolor{keyword}{template} <\textcolor{keyword}{typename} lCT, \textcolor{keyword}{typename} rT>}
\DoxyCodeLine{30 \textcolor{keyword}{inline} \mbox{\hyperlink{classstd_1_1storage_1_1st__subset__base}{std::storage::st\_subset\_base<lCT>}}\&\& operator*= (\mbox{\hyperlink{classstd_1_1storage_1_1st__subset__base}{std::storage::st\_subset\_base<lCT>}}\&\& \_lhs, \textcolor{keyword}{const} rT\& \_rhs) \{}
\DoxyCodeLine{31     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& v : \_lhs) v*=\_rhs;}
\DoxyCodeLine{32     \textcolor{keywordflow}{return} std::move(\_lhs);}
\DoxyCodeLine{33 \}}
\DoxyCodeLine{34 \textcolor{keyword}{template} <\textcolor{keyword}{typename} lCT, \textcolor{keyword}{typename} rT>}
\DoxyCodeLine{35 \textcolor{keyword}{inline} \mbox{\hyperlink{classstd_1_1storage_1_1st__subset__base}{std::storage::st\_subset\_base<lCT>}}\&\& operator/= (\mbox{\hyperlink{classstd_1_1storage_1_1st__subset__base}{std::storage::st\_subset\_base<lCT>}}\&\& \_lhs, \textcolor{keyword}{const} rT\& \_rhs) \{}
\DoxyCodeLine{36     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& v : \_lhs) v/=\_rhs;}
\DoxyCodeLine{37     \textcolor{keywordflow}{return} std::move(\_lhs);}
\DoxyCodeLine{38 \}}
\DoxyCodeLine{39 \textcolor{keyword}{template} <\textcolor{keyword}{typename} lCT, \textcolor{keyword}{typename} rT>}
\DoxyCodeLine{40 \textcolor{keyword}{inline} \mbox{\hyperlink{classstd_1_1storage_1_1st__subset__base}{std::storage::st\_subset\_base<lCT>}}\&\& operator+= (\mbox{\hyperlink{classstd_1_1storage_1_1st__subset__base}{std::storage::st\_subset\_base<lCT>}}\&\& \_lhs, \textcolor{keyword}{const} rT\& \_rhs) \{}
\DoxyCodeLine{41     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& v : \_lhs) v+=\_rhs;}
\DoxyCodeLine{42     \textcolor{keywordflow}{return} std::move(\_lhs);}
\DoxyCodeLine{43 \}}
\DoxyCodeLine{44 \textcolor{keyword}{template} <\textcolor{keyword}{typename} lCT, \textcolor{keyword}{typename} rT>}
\DoxyCodeLine{45 \textcolor{keyword}{inline} \mbox{\hyperlink{classstd_1_1storage_1_1st__subset__base}{std::storage::st\_subset\_base<lCT>}}\&\& operator-\/= (\mbox{\hyperlink{classstd_1_1storage_1_1st__subset__base}{std::storage::st\_subset\_base<lCT>}}\&\& \_lhs, \textcolor{keyword}{const} rT\& \_rhs) \{}
\DoxyCodeLine{46     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& v : \_lhs) v-\/=\_rhs;}
\DoxyCodeLine{47     \textcolor{keywordflow}{return} std::move(\_lhs);}
\DoxyCodeLine{48 \}}
\DoxyCodeLine{49 \textcolor{keyword}{template} <\textcolor{keyword}{typename} lCT, \textcolor{keyword}{typename} rT>}
\DoxyCodeLine{50 \textcolor{keyword}{inline} \mbox{\hyperlink{classstd_1_1storage_1_1st__subset__base}{std::storage::st\_subset\_base<lCT>}}\&\& operator*= (\mbox{\hyperlink{classstd_1_1storage_1_1st__subset__base}{std::storage::st\_subset\_base<lCT>}}\&\& \_lhs, \textcolor{keyword}{const} std::vector<rT>\& \_rhs) \{}
\DoxyCodeLine{51     assert(\_lhs.size() <= \_rhs.size());}
\DoxyCodeLine{52     \textcolor{keywordtype}{int} rindex = 0;}
\DoxyCodeLine{53     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& v : \_lhs) v*=\_rhs[rindex++];}
\DoxyCodeLine{54     \textcolor{keywordflow}{return} std::move(\_lhs);}
\DoxyCodeLine{55 \}}
\DoxyCodeLine{56 \textcolor{keyword}{template} <\textcolor{keyword}{typename} lCT, \textcolor{keyword}{typename} rT>}
\DoxyCodeLine{57 \textcolor{keyword}{inline} \mbox{\hyperlink{classstd_1_1storage_1_1st__subset__base}{std::storage::st\_subset\_base<lCT>}}\&\& operator/= (\mbox{\hyperlink{classstd_1_1storage_1_1st__subset__base}{std::storage::st\_subset\_base<lCT>}}\&\& \_lhs, \textcolor{keyword}{const} std::vector<rT>\& \_rhs) \{}
\DoxyCodeLine{58     assert(\_lhs.size() <= \_rhs.size());}
\DoxyCodeLine{59     \textcolor{keywordtype}{int} rindex = 0;}
\DoxyCodeLine{60     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& v : \_lhs) v/=\_rhs[rindex++];}
\DoxyCodeLine{61     \textcolor{keywordflow}{return} std::move(\_lhs);}
\DoxyCodeLine{62 \}}
\DoxyCodeLine{63 \textcolor{keyword}{template} <\textcolor{keyword}{typename} lCT, \textcolor{keyword}{typename} rT>}
\DoxyCodeLine{64 \textcolor{keyword}{inline} \mbox{\hyperlink{classstd_1_1storage_1_1st__subset__base}{std::storage::st\_subset\_base<lCT>}}\&\& operator+= (\mbox{\hyperlink{classstd_1_1storage_1_1st__subset__base}{std::storage::st\_subset\_base<lCT>}}\&\& \_lhs, \textcolor{keyword}{const} std::vector<rT>\& \_rhs) \{}
\DoxyCodeLine{65     assert(\_lhs.size() <= \_rhs.size());}
\DoxyCodeLine{66     \textcolor{keywordtype}{int} rindex = 0;}
\DoxyCodeLine{67     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& v : \_lhs) v+=\_rhs[rindex++];}
\DoxyCodeLine{68     \textcolor{keywordflow}{return} std::move(\_lhs);}
\DoxyCodeLine{69 \}}
\DoxyCodeLine{70 \textcolor{keyword}{template} <\textcolor{keyword}{typename} lCT, \textcolor{keyword}{typename} rT>}
\DoxyCodeLine{71 \textcolor{keyword}{inline} \mbox{\hyperlink{classstd_1_1storage_1_1st__subset__base}{std::storage::st\_subset\_base<lCT>}}\&\& operator-\/= (\mbox{\hyperlink{classstd_1_1storage_1_1st__subset__base}{std::storage::st\_subset\_base<lCT>}}\&\& \_lhs, \textcolor{keyword}{const} std::vector<rT>\& \_rhs) \{}
\DoxyCodeLine{72     assert(\_lhs.size() <= \_rhs.size());}
\DoxyCodeLine{73     \textcolor{keywordtype}{int} rindex = 0;}
\DoxyCodeLine{74     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& v : \_lhs) v-\/=\_rhs[rindex++];}
\DoxyCodeLine{75     \textcolor{keywordflow}{return} std::move(\_lhs);}
\DoxyCodeLine{76 \}}
\DoxyCodeLine{77 \textcolor{keyword}{template} <\textcolor{keyword}{typename} lCT, \textcolor{keyword}{typename} rCT>}
\DoxyCodeLine{78 \textcolor{keyword}{inline} \mbox{\hyperlink{classstd_1_1storage_1_1st__subset__base}{std::storage::st\_subset\_base<lCT>}}\&\& operator*= (\mbox{\hyperlink{classstd_1_1storage_1_1st__subset__base}{std::storage::st\_subset\_base<lCT>}}\&\& \_lhs, \mbox{\hyperlink{classstd_1_1storage_1_1st__subset__base}{std::storage::st\_subset\_base<rCT>}}\&\& \_rhs) \{}
\DoxyCodeLine{79     assert(\_lhs.size() <= \_rhs.size());}
\DoxyCodeLine{80     \textcolor{keywordtype}{int} rindex = 0;}
\DoxyCodeLine{81     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& v : \_lhs) v*=\_rhs[rindex++];}
\DoxyCodeLine{82     \textcolor{keywordflow}{return} std::move(\_lhs);}
\DoxyCodeLine{83 \}}
\DoxyCodeLine{84 \textcolor{keyword}{template} <\textcolor{keyword}{typename} lCT, \textcolor{keyword}{typename} rCT>}
\DoxyCodeLine{85 \textcolor{keyword}{inline} \mbox{\hyperlink{classstd_1_1storage_1_1st__subset__base}{std::storage::st\_subset\_base<lCT>}}\&\& operator/= (\mbox{\hyperlink{classstd_1_1storage_1_1st__subset__base}{std::storage::st\_subset\_base<lCT>}}\&\& \_lhs, \mbox{\hyperlink{classstd_1_1storage_1_1st__subset__base}{std::storage::st\_subset\_base<rCT>}}\&\& \_rhs) \{}
\DoxyCodeLine{86     assert(\_lhs.size() <= \_rhs.size());}
\DoxyCodeLine{87     \textcolor{keywordtype}{int} rindex = 0;}
\DoxyCodeLine{88     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& v : \_lhs) v/=\_rhs[rindex++];}
\DoxyCodeLine{89     \textcolor{keywordflow}{return} std::move(\_lhs);}
\DoxyCodeLine{90 \}}
\DoxyCodeLine{91 \textcolor{keyword}{template} <\textcolor{keyword}{typename} lCT, \textcolor{keyword}{typename} rCT>}
\DoxyCodeLine{92 \textcolor{keyword}{inline} \mbox{\hyperlink{classstd_1_1storage_1_1st__subset__base}{std::storage::st\_subset\_base<lCT>}}\&\& operator+= (\mbox{\hyperlink{classstd_1_1storage_1_1st__subset__base}{std::storage::st\_subset\_base<lCT>}}\&\& \_lhs, \mbox{\hyperlink{classstd_1_1storage_1_1st__subset__base}{std::storage::st\_subset\_base<rCT>}}\&\& \_rhs) \{}
\DoxyCodeLine{93     assert(\_lhs.size() <= \_rhs.size());}
\DoxyCodeLine{94     \textcolor{keywordtype}{int} rindex = 0;}
\DoxyCodeLine{95     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& v : \_lhs) v+=\_rhs[rindex++];}
\DoxyCodeLine{96     \textcolor{keywordflow}{return} std::move(\_lhs);}
\DoxyCodeLine{97 \}}
\DoxyCodeLine{98 \textcolor{keyword}{template} <\textcolor{keyword}{typename} lCT, \textcolor{keyword}{typename} rCT>}
\DoxyCodeLine{99 \textcolor{keyword}{inline} \mbox{\hyperlink{classstd_1_1storage_1_1st__subset__base}{std::storage::st\_subset\_base<lCT>}}\&\& operator-\/= (\mbox{\hyperlink{classstd_1_1storage_1_1st__subset__base}{std::storage::st\_subset\_base<lCT>}}\&\& \_lhs, \mbox{\hyperlink{classstd_1_1storage_1_1st__subset__base}{std::storage::st\_subset\_base<rCT>}}\&\& \_rhs) \{}
\DoxyCodeLine{100     assert(\_lhs.size() <= \_rhs.size());}
\DoxyCodeLine{101     \textcolor{keywordtype}{int} rindex = 0;}
\DoxyCodeLine{102     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& v : \_lhs) v-\/=\_rhs[rindex++];}
\DoxyCodeLine{103     \textcolor{keywordflow}{return} std::move(\_lhs);}
\DoxyCodeLine{104 \}}
\DoxyCodeLine{106 \textcolor{comment}{// subset non-\/compound operator overloads}}
\DoxyCodeLine{107 \textcolor{comment}{// return std::vector with new values because 1) std\_subset\_base doesn't hold any data and 2) should not modify input subset container;}}
\DoxyCodeLine{108 \textcolor{comment}{// std::vector as return types allows 1) direct subset assignment ("{}mat.row() = mat.col()+5;"{}), and 2) matrix/volume initialization with shape ("{}matrix mat(3,3,mat.all()+7;"{});}}
\DoxyCodeLine{109 \textcolor{comment}{// can't return rvalue reference because vector is instantiated within the function and is goes out of scope}}
\DoxyCodeLine{110 \textcolor{keyword}{template} <\textcolor{keyword}{typename} lCT, \textcolor{keyword}{typename} rT>}
\DoxyCodeLine{111 \textcolor{keyword}{inline} std::vector<typename lCT::value\_type> operator* (\textcolor{keyword}{const} \mbox{\hyperlink{classstd_1_1storage_1_1st__subset__base}{std::storage::st\_subset\_base<lCT>}}\& \_lhs, \textcolor{keyword}{const} rT\& \_rhs) \{}
\DoxyCodeLine{112     std::vector<typename lCT::value\_type> data(0);}
\DoxyCodeLine{113     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& v : \_lhs) data.push\_back(v*\_rhs);}
\DoxyCodeLine{114     \textcolor{keywordflow}{return} data;}
\DoxyCodeLine{115 \}}
\DoxyCodeLine{116 \textcolor{keyword}{template} <\textcolor{keyword}{typename} lCT, \textcolor{keyword}{typename} rT>}
\DoxyCodeLine{117 \textcolor{keyword}{inline} std::vector<typename lCT::value\_type> operator/ (\textcolor{keyword}{const} \mbox{\hyperlink{classstd_1_1storage_1_1st__subset__base}{std::storage::st\_subset\_base<lCT>}}\& \_lhs, \textcolor{keyword}{const} rT\& \_rhs) \{}
\DoxyCodeLine{118     std::vector<typename lCT::value\_type> data(0);}
\DoxyCodeLine{119     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& v : \_lhs) data.push\_back(v/\_rhs);}
\DoxyCodeLine{120     \textcolor{keywordflow}{return} data;}
\DoxyCodeLine{121 \}}
\DoxyCodeLine{122 \textcolor{keyword}{template} <\textcolor{keyword}{typename} lCT, \textcolor{keyword}{typename} rT>}
\DoxyCodeLine{123 \textcolor{keyword}{inline} std::vector<typename lCT::value\_type> operator+ (\textcolor{keyword}{const} \mbox{\hyperlink{classstd_1_1storage_1_1st__subset__base}{std::storage::st\_subset\_base<lCT>}}\& \_lhs, \textcolor{keyword}{const} rT\& \_rhs) \{}
\DoxyCodeLine{124     std::vector<typename lCT::value\_type> data(0);}
\DoxyCodeLine{125     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& v : \_lhs) data.push\_back(v+\_rhs);}
\DoxyCodeLine{126     \textcolor{keywordflow}{return} data;}
\DoxyCodeLine{127 \}}
\DoxyCodeLine{128 \textcolor{keyword}{template} <\textcolor{keyword}{typename} lCT, \textcolor{keyword}{typename} rT>}
\DoxyCodeLine{129 \textcolor{keyword}{inline} std::vector<typename lCT::value\_type> operator-\/ (\textcolor{keyword}{const} \mbox{\hyperlink{classstd_1_1storage_1_1st__subset__base}{std::storage::st\_subset\_base<lCT>}}\& \_lhs, \textcolor{keyword}{const} rT\& \_rhs) \{}
\DoxyCodeLine{130     std::vector<typename lCT::value\_type> data(0);}
\DoxyCodeLine{131     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& v : \_lhs) data.push\_back(v-\/\_rhs);}
\DoxyCodeLine{132     \textcolor{keywordflow}{return} data;}
\DoxyCodeLine{133 \}}
\DoxyCodeLine{134 \textcolor{keyword}{template} <\textcolor{keyword}{typename} lCT, \textcolor{keyword}{typename} rT>}
\DoxyCodeLine{135 \textcolor{keyword}{inline} std::vector<typename lCT::value\_type> operator* (\textcolor{keyword}{const} \mbox{\hyperlink{classstd_1_1storage_1_1st__subset__base}{std::storage::st\_subset\_base<lCT>}}\& \_lhs, \textcolor{keyword}{const} std::vector<rT>\& \_rhs) \{}
\DoxyCodeLine{136     assert(\_lhs.size() <= \_rhs.size());}
\DoxyCodeLine{137     std::vector<typename lCT::value\_type> data(0);}
\DoxyCodeLine{138     \textcolor{keywordtype}{int} rindex = 0;}
\DoxyCodeLine{139     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& v : \_lhs) data.push\_back(v*\_rhs[rindex++]);}
\DoxyCodeLine{140     \textcolor{keywordflow}{return} data;}
\DoxyCodeLine{141 \}}
\DoxyCodeLine{142 \textcolor{keyword}{template} <\textcolor{keyword}{typename} lCT, \textcolor{keyword}{typename} rT>}
\DoxyCodeLine{143 \textcolor{keyword}{inline} std::vector<typename lCT::value\_type> operator/ (\textcolor{keyword}{const} \mbox{\hyperlink{classstd_1_1storage_1_1st__subset__base}{std::storage::st\_subset\_base<lCT>}}\& \_lhs, \textcolor{keyword}{const} std::vector<rT>\& \_rhs) \{}
\DoxyCodeLine{144     assert(\_lhs.size() <= \_rhs.size());}
\DoxyCodeLine{145     std::vector<typename lCT::value\_type> data(0);}
\DoxyCodeLine{146     \textcolor{keywordtype}{int} rindex = 0;}
\DoxyCodeLine{147     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& v : \_lhs) data.push\_back(v/\_rhs[rindex++]);}
\DoxyCodeLine{148     \textcolor{keywordflow}{return} data;}
\DoxyCodeLine{149 \}}
\DoxyCodeLine{150 \textcolor{keyword}{template} <\textcolor{keyword}{typename} lCT, \textcolor{keyword}{typename} rT>}
\DoxyCodeLine{151 \textcolor{keyword}{inline} std::vector<typename lCT::value\_type> operator+ (\textcolor{keyword}{const} \mbox{\hyperlink{classstd_1_1storage_1_1st__subset__base}{std::storage::st\_subset\_base<lCT>}}\& \_lhs, \textcolor{keyword}{const} std::vector<rT>\& \_rhs) \{}
\DoxyCodeLine{152     assert(\_lhs.size() <= \_rhs.size());}
\DoxyCodeLine{153     std::vector<typename lCT::value\_type> data(0);}
\DoxyCodeLine{154     \textcolor{keywordtype}{int} rindex = 0;}
\DoxyCodeLine{155     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& v : \_lhs) data.push\_back(v+\_rhs[rindex++]);}
\DoxyCodeLine{156     \textcolor{keywordflow}{return} data;}
\DoxyCodeLine{157 \}}
\DoxyCodeLine{158 \textcolor{keyword}{template} <\textcolor{keyword}{typename} lCT, \textcolor{keyword}{typename} rT>}
\DoxyCodeLine{159 \textcolor{keyword}{inline} std::vector<typename lCT::value\_type> operator-\/ (\textcolor{keyword}{const} \mbox{\hyperlink{classstd_1_1storage_1_1st__subset__base}{std::storage::st\_subset\_base<lCT>}}\& \_lhs, \textcolor{keyword}{const} std::vector<rT>\& \_rhs) \{}
\DoxyCodeLine{160     assert(\_lhs.size() <= \_rhs.size());}
\DoxyCodeLine{161     std::vector<typename lCT::value\_type> data(0);}
\DoxyCodeLine{162     \textcolor{keywordtype}{int} rindex = 0;}
\DoxyCodeLine{163     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& v : \_lhs) data.push\_back(v-\/\_rhs[rindex++]);}
\DoxyCodeLine{164     \textcolor{keywordflow}{return} data;}
\DoxyCodeLine{165 \}}
\DoxyCodeLine{166 \textcolor{keyword}{template} <\textcolor{keyword}{typename} lCT, \textcolor{keyword}{typename} rCT>}
\DoxyCodeLine{167 \textcolor{keyword}{inline} std::vector<typename lCT::value\_type> operator* (\textcolor{keyword}{const} \mbox{\hyperlink{classstd_1_1storage_1_1st__subset__base}{std::storage::st\_subset\_base<lCT>}}\& \_lhs, \textcolor{keyword}{const} \mbox{\hyperlink{classstd_1_1storage_1_1st__subset__base}{std::storage::st\_subset\_base<rCT>}}\& \_rhs) \{}
\DoxyCodeLine{168     assert(\_lhs.size() <= \_rhs.size());}
\DoxyCodeLine{169     std::vector<typename lCT::value\_type> data(0);}
\DoxyCodeLine{170     \textcolor{keywordtype}{int} rindex = 0;}
\DoxyCodeLine{171     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& v : \_lhs) data.push\_back(v*\_rhs[rindex++]);}
\DoxyCodeLine{172     \textcolor{keywordflow}{return} data;}
\DoxyCodeLine{173 \}}
\DoxyCodeLine{174 \textcolor{keyword}{template} <\textcolor{keyword}{typename} lCT, \textcolor{keyword}{typename} rCT>}
\DoxyCodeLine{175 \textcolor{keyword}{inline} std::vector<typename lCT::value\_type> operator/ (\textcolor{keyword}{const} \mbox{\hyperlink{classstd_1_1storage_1_1st__subset__base}{std::storage::st\_subset\_base<lCT>}}\& \_lhs, \textcolor{keyword}{const} \mbox{\hyperlink{classstd_1_1storage_1_1st__subset__base}{std::storage::st\_subset\_base<rCT>}}\& \_rhs) \{}
\DoxyCodeLine{176     assert(\_lhs.size() <= \_rhs.size());}
\DoxyCodeLine{177     std::vector<typename lCT::value\_type> data(0);}
\DoxyCodeLine{178     \textcolor{keywordtype}{int} rindex = 0;}
\DoxyCodeLine{179     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& v : \_lhs) data.push\_back(v/\_rhs[rindex++]);}
\DoxyCodeLine{180     \textcolor{keywordflow}{return} data;}
\DoxyCodeLine{181 \}}
\DoxyCodeLine{182 \textcolor{keyword}{template} <\textcolor{keyword}{typename} lCT, \textcolor{keyword}{typename} rCT>}
\DoxyCodeLine{183 \textcolor{keyword}{inline} std::vector<typename lCT::value\_type> operator+ (\textcolor{keyword}{const} \mbox{\hyperlink{classstd_1_1storage_1_1st__subset__base}{std::storage::st\_subset\_base<lCT>}}\& \_lhs, \textcolor{keyword}{const} \mbox{\hyperlink{classstd_1_1storage_1_1st__subset__base}{std::storage::st\_subset\_base<rCT>}}\& \_rhs) \{}
\DoxyCodeLine{184     assert(\_lhs.size() <= \_rhs.size());}
\DoxyCodeLine{185     std::vector<typename lCT::value\_type> data(0);}
\DoxyCodeLine{186     \textcolor{keywordtype}{int} rindex = 0;}
\DoxyCodeLine{187     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& v : \_lhs) data.push\_back(v+\_rhs[rindex++]);}
\DoxyCodeLine{188     \textcolor{keywordflow}{return} data;}
\DoxyCodeLine{189 \}}
\DoxyCodeLine{190 \textcolor{keyword}{template} <\textcolor{keyword}{typename} lCT, \textcolor{keyword}{typename} rCT>}
\DoxyCodeLine{191 \textcolor{keyword}{inline} std::vector<typename lCT::value\_type> operator-\/ (\textcolor{keyword}{const} \mbox{\hyperlink{classstd_1_1storage_1_1st__subset__base}{std::storage::st\_subset\_base<lCT>}}\& \_lhs, \textcolor{keyword}{const} \mbox{\hyperlink{classstd_1_1storage_1_1st__subset__base}{std::storage::st\_subset\_base<rCT>}}\& \_rhs) \{}
\DoxyCodeLine{192     assert(\_lhs.size() <= \_rhs.size());}
\DoxyCodeLine{193     std::vector<typename lCT::value\_type> data(0);}
\DoxyCodeLine{194     \textcolor{keywordtype}{int} rindex = 0;}
\DoxyCodeLine{195     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& v : \_lhs) data.push\_back(v-\/\_rhs[rindex++]);}
\DoxyCodeLine{196     \textcolor{keywordflow}{return} data;}
\DoxyCodeLine{197 \}}
\DoxyCodeLine{199 \textcolor{comment}{// std::vector compound operators (to allow chained inline operations)}}
\DoxyCodeLine{200 \textcolor{comment}{// std::vector can}}
\DoxyCodeLine{201 \textcolor{keyword}{template} <\textcolor{keyword}{typename} lT, \textcolor{keyword}{typename} rT>}
\DoxyCodeLine{202 \textcolor{keyword}{inline} std::vector<lT>\& operator*= (std::vector<lT>\& \_lhs, \textcolor{keyword}{const} rT\& \_rhs) \{}
\DoxyCodeLine{203     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& v : \_lhs) v *= \_rhs;}
\DoxyCodeLine{204     \textcolor{keywordflow}{return} \_lhs;}
\DoxyCodeLine{205 \}}
\DoxyCodeLine{206 \textcolor{keyword}{template} <\textcolor{keyword}{typename} lT, \textcolor{keyword}{typename} rT>}
\DoxyCodeLine{207 \textcolor{keyword}{inline} std::vector<lT> operator/= (std::vector<lT>\& \_lhs, \textcolor{keyword}{const} rT\& \_rhs) \{}
\DoxyCodeLine{208     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& v : \_lhs) v /= \_rhs;}
\DoxyCodeLine{209     \textcolor{keywordflow}{return} \_lhs;}
\DoxyCodeLine{210 \}}
\DoxyCodeLine{211 \textcolor{keyword}{template} <\textcolor{keyword}{typename} lT, \textcolor{keyword}{typename} rT>}
\DoxyCodeLine{212 \textcolor{keyword}{inline} std::vector<lT>\& operator+= (std::vector<lT>\& \_lhs, \textcolor{keyword}{const} rT\& \_rhs) \{}
\DoxyCodeLine{213     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& v : \_lhs) v += \_rhs;}
\DoxyCodeLine{214     \textcolor{keywordflow}{return} \_lhs;}
\DoxyCodeLine{215 \}}
\DoxyCodeLine{216 \textcolor{keyword}{template} <\textcolor{keyword}{typename} lT, \textcolor{keyword}{typename} rT>}
\DoxyCodeLine{217 \textcolor{keyword}{inline} std::vector<lT>\& operator-\/= (std::vector<lT>\& \_lhs, \textcolor{keyword}{const} rT\& \_rhs) \{}
\DoxyCodeLine{218     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& v : \_lhs) v -\/= \_rhs;}
\DoxyCodeLine{219     \textcolor{keywordflow}{return} \_lhs;}
\DoxyCodeLine{220 \}}
\DoxyCodeLine{221 \textcolor{keyword}{template} <\textcolor{keyword}{typename} lT, \textcolor{keyword}{typename} rT>}
\DoxyCodeLine{222 \textcolor{keyword}{inline} std::vector<lT>\& operator*= (std::vector<lT>\& \_lhs, \textcolor{keyword}{const} std::vector<rT>\& \_rhs) \{}
\DoxyCodeLine{223     assert(\_lhs.size() <= \_rhs.size());}
\DoxyCodeLine{224     \textcolor{keywordtype}{int} rindex = 0;}
\DoxyCodeLine{225     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& v : \_lhs) v *= \_rhs[rindex++];}
\DoxyCodeLine{226     \textcolor{keywordflow}{return} \_lhs;}
\DoxyCodeLine{227 \}}
\DoxyCodeLine{228 \textcolor{keyword}{template} <\textcolor{keyword}{typename} lT, \textcolor{keyword}{typename} rT>}
\DoxyCodeLine{229 \textcolor{keyword}{inline} std::vector<lT>\& operator/= (std::vector<lT>\& \_lhs, \textcolor{keyword}{const} std::vector<rT>\& \_rhs) \{}
\DoxyCodeLine{230     assert(\_lhs.size() <= \_rhs.size());}
\DoxyCodeLine{231     \textcolor{keywordtype}{int} rindex = 0;}
\DoxyCodeLine{232     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& v : \_lhs) v /= \_rhs[rindex++];}
\DoxyCodeLine{233     \textcolor{keywordflow}{return} \_lhs;}
\DoxyCodeLine{234 \}}
\DoxyCodeLine{235 \textcolor{keyword}{template} <\textcolor{keyword}{typename} lT, \textcolor{keyword}{typename} rT>}
\DoxyCodeLine{236 \textcolor{keyword}{inline} std::vector<lT>\& operator+= (std::vector<lT>\& \_lhs, \textcolor{keyword}{const} std::vector<rT>\& \_rhs) \{}
\DoxyCodeLine{237     assert(\_lhs.size() <= \_rhs.size());}
\DoxyCodeLine{238     \textcolor{keywordtype}{int} rindex = 0;}
\DoxyCodeLine{239     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& v : \_lhs) v += \_rhs[rindex++];}
\DoxyCodeLine{240     \textcolor{keywordflow}{return} \_lhs;}
\DoxyCodeLine{241 \}}
\DoxyCodeLine{242 \textcolor{keyword}{template} <\textcolor{keyword}{typename} lT, \textcolor{keyword}{typename} rT>}
\DoxyCodeLine{243 \textcolor{keyword}{inline} std::vector<lT>\& operator-\/= (std::vector<lT>\& \_lhs, \textcolor{keyword}{const} std::vector<rT>\& \_rhs) \{}
\DoxyCodeLine{244     assert(\_lhs.size() <= \_rhs.size());}
\DoxyCodeLine{245     \textcolor{keywordtype}{int} rindex = 0;}
\DoxyCodeLine{246     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& v : \_lhs) v -\/= \_rhs[rindex++];}
\DoxyCodeLine{247     \textcolor{keywordflow}{return} \_lhs;}
\DoxyCodeLine{248 \}}
\DoxyCodeLine{249 \textcolor{keyword}{template} <\textcolor{keyword}{typename} lT, \textcolor{keyword}{typename} rCT>}
\DoxyCodeLine{250 \textcolor{keyword}{inline} std::vector<lT>\& operator*= (std::vector<lT>\& \_lhs, \mbox{\hyperlink{classstd_1_1storage_1_1st__subset__base}{std::storage::st\_subset\_base<rCT>}}\&\& \_rhs) \{}
\DoxyCodeLine{251     assert(\_lhs.size() <= \_rhs.size());}
\DoxyCodeLine{252     \textcolor{keywordtype}{int} rindex = 0;}
\DoxyCodeLine{253     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& v : \_lhs) v *= \_rhs[rindex++];}
\DoxyCodeLine{254     \textcolor{keywordflow}{return} \_lhs;}
\DoxyCodeLine{255 \}}
\DoxyCodeLine{256 \textcolor{keyword}{template} <\textcolor{keyword}{typename} lT, \textcolor{keyword}{typename} rCT>}
\DoxyCodeLine{257 \textcolor{keyword}{inline} std::vector<lT>\& operator/= (std::vector<lT>\& \_lhs, \mbox{\hyperlink{classstd_1_1storage_1_1st__subset__base}{std::storage::st\_subset\_base<rCT>}}\&\& \_rhs) \{}
\DoxyCodeLine{258     assert(\_lhs.size() <= \_rhs.size());}
\DoxyCodeLine{259     \textcolor{keywordtype}{int} rindex = 0;}
\DoxyCodeLine{260     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& v : \_lhs) v /= \_rhs[rindex++];}
\DoxyCodeLine{261     \textcolor{keywordflow}{return} \_lhs;}
\DoxyCodeLine{262 \}}
\DoxyCodeLine{263 \textcolor{keyword}{template} <\textcolor{keyword}{typename} lT, \textcolor{keyword}{typename} rCT>}
\DoxyCodeLine{264 \textcolor{keyword}{inline} std::vector<lT>\& operator+= (std::vector<lT>\& \_lhs, \mbox{\hyperlink{classstd_1_1storage_1_1st__subset__base}{std::storage::st\_subset\_base<rCT>}}\&\& \_rhs) \{}
\DoxyCodeLine{265     assert(\_lhs.size() <= \_rhs.size());}
\DoxyCodeLine{266     \textcolor{keywordtype}{int} rindex = 0;}
\DoxyCodeLine{267     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& v : \_lhs) v += \_rhs[rindex++];}
\DoxyCodeLine{268     \textcolor{keywordflow}{return} \_lhs;}
\DoxyCodeLine{269 \}}
\DoxyCodeLine{270 \textcolor{keyword}{template} <\textcolor{keyword}{typename} lT, \textcolor{keyword}{typename} rCT>}
\DoxyCodeLine{271 \textcolor{keyword}{inline} std::vector<lT>\& operator-\/= (std::vector<lT>\& \_lhs, \mbox{\hyperlink{classstd_1_1storage_1_1st__subset__base}{std::storage::st\_subset\_base<rCT>}}\&\& \_rhs) \{}
\DoxyCodeLine{272     assert(\_lhs.size() <= \_rhs.size());}
\DoxyCodeLine{273     \textcolor{keywordtype}{int} rindex = 0;}
\DoxyCodeLine{274     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& v : \_lhs) v -\/= \_rhs[rindex++];}
\DoxyCodeLine{275     \textcolor{keywordflow}{return} \_lhs;}
\DoxyCodeLine{276 \}}
\DoxyCodeLine{278 \textcolor{comment}{// std::vector non-\/compound operators}}
\DoxyCodeLine{279 \textcolor{keyword}{template} <\textcolor{keyword}{typename} lT, \textcolor{keyword}{typename} rT>}
\DoxyCodeLine{280 \textcolor{keyword}{inline} std::vector<lT> operator* (\textcolor{keyword}{const} std::vector<lT>\& \_lhs, \textcolor{keyword}{const} rT\& \_rhs) \{}
\DoxyCodeLine{281     std::vector<lT> data(0);}
\DoxyCodeLine{282     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& v : \_lhs) data.push\_back(v*\_rhs);}
\DoxyCodeLine{283     \textcolor{keywordflow}{return} data;}
\DoxyCodeLine{284 \}}
\DoxyCodeLine{285 \textcolor{keyword}{template} <\textcolor{keyword}{typename} lT, \textcolor{keyword}{typename} rT>}
\DoxyCodeLine{286 \textcolor{keyword}{inline} std::vector<lT> operator/ (\textcolor{keyword}{const} std::vector<lT>\& \_lhs, \textcolor{keyword}{const} rT\& \_rhs) \{}
\DoxyCodeLine{287     std::vector<lT> data(0);}
\DoxyCodeLine{288     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& v : \_lhs) data.push\_back(v/\_rhs);}
\DoxyCodeLine{289     \textcolor{keywordflow}{return} data;}
\DoxyCodeLine{290 \}}
\DoxyCodeLine{291 \textcolor{keyword}{template} <\textcolor{keyword}{typename} lT, \textcolor{keyword}{typename} rT>}
\DoxyCodeLine{292 \textcolor{keyword}{inline} std::vector<lT> operator+ (\textcolor{keyword}{const} std::vector<lT>\& \_lhs, \textcolor{keyword}{const} rT\& \_rhs) \{}
\DoxyCodeLine{293     std::vector<lT> data(0);}
\DoxyCodeLine{294     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& v : \_lhs) data.push\_back(v+\_rhs);}
\DoxyCodeLine{295     \textcolor{keywordflow}{return} data;}
\DoxyCodeLine{296 \}}
\DoxyCodeLine{297 \textcolor{keyword}{template} <\textcolor{keyword}{typename} lT, \textcolor{keyword}{typename} rT>}
\DoxyCodeLine{298 \textcolor{keyword}{inline} std::vector<lT> operator-\/ (\textcolor{keyword}{const} std::vector<lT>\& \_lhs, \textcolor{keyword}{const} rT\& \_rhs) \{}
\DoxyCodeLine{299     std::vector<lT> data(0);}
\DoxyCodeLine{300     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& v : \_lhs) data.push\_back(v-\/\_rhs);}
\DoxyCodeLine{301     \textcolor{keywordflow}{return} data;}
\DoxyCodeLine{302 \}}
\DoxyCodeLine{303 \textcolor{keyword}{template} <\textcolor{keyword}{typename} lT, \textcolor{keyword}{typename} rT>}
\DoxyCodeLine{304 \textcolor{keyword}{inline} std::vector<lT> operator* (\textcolor{keyword}{const} std::vector<lT>\& \_lhs, \textcolor{keyword}{const} std::vector<rT>\& \_rhs) \{}
\DoxyCodeLine{305     assert(\_lhs.size() <= \_rhs.size());}
\DoxyCodeLine{306     std::vector<lT> data(0);}
\DoxyCodeLine{307     \textcolor{keywordtype}{int} rindex = 0;}
\DoxyCodeLine{308     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& v : \_lhs) data.push\_back(v*\_rhs[rindex++]);}
\DoxyCodeLine{309     \textcolor{keywordflow}{return} data;}
\DoxyCodeLine{310 \}}
\DoxyCodeLine{311 \textcolor{keyword}{template} <\textcolor{keyword}{typename} lT, \textcolor{keyword}{typename} rT>}
\DoxyCodeLine{312 \textcolor{keyword}{inline} std::vector<lT> operator/ (\textcolor{keyword}{const} std::vector<lT>\& \_lhs, \textcolor{keyword}{const} std::vector<rT>\& \_rhs) \{}
\DoxyCodeLine{313     assert(\_lhs.size() <= \_rhs.size());}
\DoxyCodeLine{314     std::vector<lT> data(0);}
\DoxyCodeLine{315     \textcolor{keywordtype}{int} rindex = 0;}
\DoxyCodeLine{316     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& v : \_lhs) data.push\_back(v/\_rhs[rindex++]);}
\DoxyCodeLine{317     \textcolor{keywordflow}{return} data;}
\DoxyCodeLine{318 \}}
\DoxyCodeLine{319 \textcolor{keyword}{template} <\textcolor{keyword}{typename} lT, \textcolor{keyword}{typename} rT>}
\DoxyCodeLine{320 \textcolor{keyword}{inline} std::vector<lT> operator+ (\textcolor{keyword}{const} std::vector<lT>\& \_lhs, \textcolor{keyword}{const} std::vector<rT>\& \_rhs) \{}
\DoxyCodeLine{321     assert(\_lhs.size() <= \_rhs.size());}
\DoxyCodeLine{322     std::vector<lT> data(0);}
\DoxyCodeLine{323     \textcolor{keywordtype}{int} rindex = 0;}
\DoxyCodeLine{324     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& v : \_lhs) data.push\_back(v+\_rhs[rindex++]);}
\DoxyCodeLine{325     \textcolor{keywordflow}{return} data;}
\DoxyCodeLine{326 \}}
\DoxyCodeLine{327 \textcolor{keyword}{template} <\textcolor{keyword}{typename} lT, \textcolor{keyword}{typename} rT>}
\DoxyCodeLine{328 \textcolor{keyword}{inline} std::vector<lT> operator-\/ (\textcolor{keyword}{const} std::vector<lT>\& \_lhs, \textcolor{keyword}{const} std::vector<rT>\& \_rhs) \{}
\DoxyCodeLine{329     assert(\_lhs.size() <= \_rhs.size());}
\DoxyCodeLine{330     std::vector<lT> data(0);}
\DoxyCodeLine{331     \textcolor{keywordtype}{int} rindex = 0;}
\DoxyCodeLine{332     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& v : \_lhs) data.push\_back(v-\/\_rhs[rindex++]);}
\DoxyCodeLine{333     \textcolor{keywordflow}{return} data;}
\DoxyCodeLine{334 \}}
\DoxyCodeLine{335 \textcolor{keyword}{template} <\textcolor{keyword}{typename} lT, \textcolor{keyword}{typename} rCT>}
\DoxyCodeLine{336 \textcolor{keyword}{inline} std::vector<lT> operator* (\textcolor{keyword}{const} std::vector<lT>\& \_lhs, \textcolor{keyword}{const} \mbox{\hyperlink{classstd_1_1storage_1_1st__subset__base}{std::storage::st\_subset\_base<rCT>}}\& \_rhs) \{}
\DoxyCodeLine{337     assert(\_lhs.size() <= \_rhs.size());}
\DoxyCodeLine{338     std::vector<lT> data(0);}
\DoxyCodeLine{339     \textcolor{keywordtype}{int} rindex = 0;}
\DoxyCodeLine{340     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& v : \_lhs) data.push\_back(v*\_rhs[rindex++]);}
\DoxyCodeLine{341     \textcolor{keywordflow}{return} data;}
\DoxyCodeLine{342 \}}
\DoxyCodeLine{343 \textcolor{keyword}{template} <\textcolor{keyword}{typename} lT, \textcolor{keyword}{typename} rCT>}
\DoxyCodeLine{344 \textcolor{keyword}{inline} std::vector<lT> operator/ (\textcolor{keyword}{const} std::vector<lT>\& \_lhs, \textcolor{keyword}{const} \mbox{\hyperlink{classstd_1_1storage_1_1st__subset__base}{std::storage::st\_subset\_base<rCT>}}\& \_rhs) \{}
\DoxyCodeLine{345     assert(\_lhs.size() <= \_rhs.size());}
\DoxyCodeLine{346     std::vector<lT> data(0);}
\DoxyCodeLine{347     \textcolor{keywordtype}{int} rindex = 0;}
\DoxyCodeLine{348     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& v : \_lhs) data.push\_back(v/\_rhs[rindex++]);}
\DoxyCodeLine{349     \textcolor{keywordflow}{return} data;}
\DoxyCodeLine{350 \}}
\DoxyCodeLine{351 \textcolor{keyword}{template} <\textcolor{keyword}{typename} lT, \textcolor{keyword}{typename} rCT>}
\DoxyCodeLine{352 \textcolor{keyword}{inline} std::vector<lT> operator+ (\textcolor{keyword}{const} std::vector<lT>\& \_lhs, \textcolor{keyword}{const} \mbox{\hyperlink{classstd_1_1storage_1_1st__subset__base}{std::storage::st\_subset\_base<rCT>}}\& \_rhs) \{}
\DoxyCodeLine{353     assert(\_lhs.size() <= \_rhs.size());}
\DoxyCodeLine{354     std::vector<lT> data(0);}
\DoxyCodeLine{355     \textcolor{keywordtype}{int} rindex = 0;}
\DoxyCodeLine{356     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& v : \_lhs) data.push\_back(v+\_rhs[rindex++]);}
\DoxyCodeLine{357     \textcolor{keywordflow}{return} data;}
\DoxyCodeLine{358 \}}
\DoxyCodeLine{359 \textcolor{keyword}{template} <\textcolor{keyword}{typename} lT, \textcolor{keyword}{typename} rCT>}
\DoxyCodeLine{360 \textcolor{keyword}{inline} std::vector<lT> operator-\/ (\textcolor{keyword}{const} std::vector<lT>\& \_lhs, \textcolor{keyword}{const} \mbox{\hyperlink{classstd_1_1storage_1_1st__subset__base}{std::storage::st\_subset\_base<rCT>}}\& \_rhs) \{}
\DoxyCodeLine{361     assert(\_lhs.size() <= \_rhs.size());}
\DoxyCodeLine{362     std::vector<lT> data(0);}
\DoxyCodeLine{363     \textcolor{keywordtype}{int} rindex = 0;}
\DoxyCodeLine{364     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& v : \_lhs) data.push\_back(v-\/\_rhs[rindex++]);}
\DoxyCodeLine{365     \textcolor{keywordflow}{return} data;}
\DoxyCodeLine{366 \}}
\DoxyCodeLine{369 \textcolor{comment}{// VECTOR NUMERIC PRESETS}}
\DoxyCodeLine{370 \textcolor{keyword}{namespace }std \{}
\DoxyCodeLine{371 \textcolor{keyword}{namespace }vector\_presets \{}
\DoxyCodeLine{372 \textcolor{keyword}{template} <\textcolor{keyword}{typename} \_type>}
\DoxyCodeLine{373 vector<\_type> linspace(\textcolor{keywordtype}{int} \_s, \_type \_low, \_type \_high) \{}
\DoxyCodeLine{374     \textcolor{keyword}{static\_assert}(std::is\_arithmetic<\_type>::value, \textcolor{stringliteral}{"{}PRESET ONLY AVAILABLE TO NUMERIC TYPES"{}});}
\DoxyCodeLine{375     vector<\_type> lin(\_s);}
\DoxyCodeLine{376     \_type step = ((\_high-\/\_low)/(\_s-\/1));}
\DoxyCodeLine{377     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i<\_s; i++) lin[i] = static\_cast<\_type>(step*i);}
\DoxyCodeLine{378     \textcolor{keywordflow}{return} lin;}
\DoxyCodeLine{379 \}}
\DoxyCodeLine{380 \}  \textcolor{comment}{// namespace vector\_presets}}
\DoxyCodeLine{383 \textcolor{comment}{}\textcolor{comment}{// NUMERIC TYPEDEFS}}
\DoxyCodeLine{384 \textcolor{keyword}{typedef} matrix<double> matrixDouble;}
\DoxyCodeLine{385 \textcolor{keyword}{typedef} matrix<int>    matrixInt;}
\DoxyCodeLine{386 \textcolor{keyword}{typedef} matrix<size\_t> matrixUInt;}
\DoxyCodeLine{387 \textcolor{keyword}{typedef} matrix<float>  matrixFloat;}
\DoxyCodeLine{390 \textcolor{comment}{// MATRIX NUMERIC PRESETS}}
\DoxyCodeLine{391 \textcolor{keyword}{namespace }matrix\_presets \{}
\DoxyCodeLine{392 \textcolor{keyword}{template} <\textcolor{keyword}{typename} \_type>}
\DoxyCodeLine{393 \mbox{\hyperlink{classstd_1_1matrix}{std::matrix<\_type>}} zeros(\textcolor{keywordtype}{int} \_r, \textcolor{keywordtype}{int} \_c) \{}
\DoxyCodeLine{394     \textcolor{keyword}{static\_assert}(std::is\_arithmetic<\_type>::value, \textcolor{stringliteral}{"{}PRESET ONLY AVAILABLE TO NUMERIC TYPES"{}});}
\DoxyCodeLine{395     \textcolor{keywordflow}{return} \mbox{\hyperlink{classstd_1_1matrix}{std::matrix<\_type>}}(\_r, \_c, 0);}
\DoxyCodeLine{396 \}}
\DoxyCodeLine{397 \textcolor{keyword}{template} <\textcolor{keyword}{typename} \_type>}
\DoxyCodeLine{398 \mbox{\hyperlink{classstd_1_1matrix}{std::matrix<\_type>}} ones(\textcolor{keywordtype}{int} \_r, \textcolor{keywordtype}{int} \_c) \{}
\DoxyCodeLine{399     \textcolor{keyword}{static\_assert}(std::is\_arithmetic<\_type>::value, \textcolor{stringliteral}{"{}PRESET ONLY AVAILABLE TO NUMERIC TYPES"{}});}
\DoxyCodeLine{400     \textcolor{keywordflow}{return} \mbox{\hyperlink{classstd_1_1matrix}{std::matrix<\_type>}}(\_r, \_c, 1);}
\DoxyCodeLine{401 \}}
\DoxyCodeLine{402 \textcolor{keyword}{template} <\textcolor{keyword}{typename} \_type>}
\DoxyCodeLine{403 \mbox{\hyperlink{classstd_1_1matrix}{std::matrix<\_type>}} square(\textcolor{keywordtype}{int} \_s) \{}
\DoxyCodeLine{404     \textcolor{keyword}{static\_assert}(std::is\_arithmetic<\_type>::value, \textcolor{stringliteral}{"{}PRESET ONLY AVAILABLE TO NUMERIC TYPES"{}});}
\DoxyCodeLine{405     \textcolor{keywordflow}{return} \mbox{\hyperlink{classstd_1_1matrix}{std::matrix<\_type>}} (\_s, \_s, 0.0);}
\DoxyCodeLine{406 \}}
\DoxyCodeLine{407 \textcolor{keyword}{template} <\textcolor{keyword}{typename} \_type>}
\DoxyCodeLine{408 \mbox{\hyperlink{classstd_1_1matrix}{std::matrix<\_type>}} list(\textcolor{keywordtype}{int} \_s) \{}
\DoxyCodeLine{409     \textcolor{keyword}{static\_assert}(std::is\_arithmetic<\_type>::value, \textcolor{stringliteral}{"{}PRESET ONLY AVAILABLE TO NUMERIC TYPES"{}});}
\DoxyCodeLine{410     \textcolor{keywordflow}{return} \mbox{\hyperlink{classstd_1_1matrix}{std::matrix<\_type>}} (\_s, 1, \textcolor{keyword}{static\_cast<}\_type\textcolor{keyword}{>}(0));}
\DoxyCodeLine{411 \}}
\DoxyCodeLine{412 \textcolor{keyword}{template} <\textcolor{keyword}{typename} \_type>}
\DoxyCodeLine{413 \mbox{\hyperlink{classstd_1_1matrix}{std::matrix<\_type>}} identity(\textcolor{keywordtype}{int} \_s) \{}
\DoxyCodeLine{414     \textcolor{keyword}{static\_assert}(std::is\_arithmetic<\_type>::value, \textcolor{stringliteral}{"{}PRESET ONLY AVAILABLE TO NUMERIC TYPES"{}});}
\DoxyCodeLine{415     \mbox{\hyperlink{classstd_1_1matrix}{std::matrix<\_type>}} ident(\_s, \_s, 0.0);}
\DoxyCodeLine{416     ident[ident.diag()] = std::vector<\_type> (\_s, \textcolor{keyword}{static\_cast<}\_type\textcolor{keyword}{>}(1));}
\DoxyCodeLine{417     \textcolor{keywordflow}{return} ident;}
\DoxyCodeLine{418 \}}
\DoxyCodeLine{419 \textcolor{keyword}{template} <\textcolor{keyword}{typename} \_type>}
\DoxyCodeLine{420 \mbox{\hyperlink{classstd_1_1matrix}{std::matrix<\_type>}} random(\textcolor{keywordtype}{int} \_r, \textcolor{keywordtype}{int} \_c) \{}
\DoxyCodeLine{421     \textcolor{keyword}{static\_assert}(std::is\_arithmetic<\_type>::value, \textcolor{stringliteral}{"{}PRESET ONLY AVAILABLE TO NUMERIC TYPES"{}});}
\DoxyCodeLine{422     std::vector<\_type> vec(\_r*\_c);}
\DoxyCodeLine{423     std::mt19937 rng(std::time(\textcolor{keyword}{nullptr}));}
\DoxyCodeLine{424     std::normal\_distribution<float> normal(0, 50);}
\DoxyCodeLine{425     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& val : vec) val = normal(rng);}
\DoxyCodeLine{426     \textcolor{keywordflow}{return} \mbox{\hyperlink{classstd_1_1matrix}{std::matrix<\_type>}} (vec, \_r, \_c);}
\DoxyCodeLine{427 \}}
\DoxyCodeLine{428 \textcolor{keyword}{template} <\textcolor{keyword}{typename} \_type>}
\DoxyCodeLine{429 \mbox{\hyperlink{classstd_1_1matrix}{std::matrix<\_type>}} linspace(\textcolor{keywordtype}{int} \_s, \_type \_low, \_type \_high) \{}
\DoxyCodeLine{430     \textcolor{keyword}{static\_assert}(std::is\_arithmetic<\_type>::value, \textcolor{stringliteral}{"{}PRESET ONLY AVAILABLE TO NUMERIC TYPES"{}});}
\DoxyCodeLine{431     \mbox{\hyperlink{classstd_1_1matrix}{std::matrix<\_type>}} lin(1, \_s);}
\DoxyCodeLine{432     \_type step = ((\_high-\/\_low)/(\_s-\/1));}
\DoxyCodeLine{433     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i < \_s; i++) lin(0, i) = step*i;}
\DoxyCodeLine{434     \textcolor{keywordflow}{return} lin;}
\DoxyCodeLine{435 \}}
\DoxyCodeLine{436 \}  \textcolor{comment}{// namespace matrix\_presets}}
\DoxyCodeLine{439 \textcolor{comment}{}\textcolor{comment}{// SORTING METHODS (for std::vector, std::matrix and std::volume)}}
\DoxyCodeLine{440 \textcolor{keyword}{template} <\textcolor{keyword}{typename} \_type>}
\DoxyCodeLine{441 std::vector<size\_t> sort\_indexes(\textcolor{keyword}{const} std::vector<\_type> \&vec) \{}
\DoxyCodeLine{442     \textcolor{comment}{// initialize original index locations}}
\DoxyCodeLine{443     std::vector<size\_t> idx(vec.size());}
\DoxyCodeLine{444     std::iota(idx.begin(), idx.end(), 0);}
\DoxyCodeLine{445     \textcolor{comment}{// sort indexes based on comparing values in vec}}
\DoxyCodeLine{446     std::sort(idx.begin(), idx.end(), [\&vec](\textcolor{keywordtype}{size\_t} i1, \textcolor{keywordtype}{size\_t} i2) \{ return vec[i1] < vec[i2]; \});}
\DoxyCodeLine{447     \textcolor{keywordflow}{return} idx;}
\DoxyCodeLine{448 \}}
\DoxyCodeLine{449 \textcolor{comment}{// sorts within the whole matrix \& volume, returns matrix with order}}
\DoxyCodeLine{450 \textcolor{comment}{// for segment sorting, call each segment separately e.g. sort\_indexes(mat[mat.row(47)]);}}
\DoxyCodeLine{451 \textcolor{keyword}{template} <\textcolor{keyword}{typename} \_type>}
\DoxyCodeLine{452 \mbox{\hyperlink{classstd_1_1matrix}{std::matrix<size\_t>}} sort\_indexes(\textcolor{keyword}{const} \mbox{\hyperlink{classstd_1_1matrix}{std::matrix<\_type>}} \&mat) \{}
\DoxyCodeLine{453     \textcolor{keywordflow}{return} \mbox{\hyperlink{classstd_1_1matrix}{std::matrix<\_type>}}(sort\_indexes(mat.vector()), mat.\mbox{\hyperlink{classstd_1_1matrix_a7b2fe3de9892ab5589361e5ed430faa4}{rows}}(), mat.\mbox{\hyperlink{classstd_1_1matrix_ad2cc55486d807add906143d7cbdad232}{cols}}());}
\DoxyCodeLine{454 \}}
\DoxyCodeLine{455 \textcolor{comment}{// template <typename \_type>}}
\DoxyCodeLine{456 \textcolor{comment}{// std::matrix<size\_t> sort\_indexes(const std::volume<\_type> \&vol) \{}}
\DoxyCodeLine{457 \textcolor{comment}{//  return std::volume<\_type>(sort\_indexes(vol.vector()),vol.levels(),vol.rows(),vol.cols());}}
\DoxyCodeLine{458 \textcolor{comment}{// \}}}
\DoxyCodeLine{460 \textcolor{comment}{}\textcolor{comment}{// SCALAR NON-\/MATRIX NUMERIC STUFF}}
\DoxyCodeLine{461 \textcolor{keyword}{inline} \textcolor{keywordtype}{float} norm(\textcolor{keywordtype}{float} x, \textcolor{keywordtype}{float} y) \{}
\DoxyCodeLine{462     \textcolor{keywordflow}{return} sqrt(pow(x, 2) + pow(y, 2));}
\DoxyCodeLine{463 \}}
\DoxyCodeLine{464 \textcolor{keyword}{inline} \textcolor{keywordtype}{float} norm(\textcolor{keywordtype}{float} x, \textcolor{keywordtype}{float} y, \textcolor{keywordtype}{float} z) \{}
\DoxyCodeLine{465     \textcolor{keywordflow}{return} sqrt(pow(x, 2) + pow(y, 2) + pow(z, 2));}
\DoxyCodeLine{466 \}}
\DoxyCodeLine{467 \textcolor{keyword}{inline} \textcolor{keywordtype}{float} deg2rad(\textcolor{keywordtype}{float} deg) \{}
\DoxyCodeLine{468     \textcolor{keywordflow}{return} deg * M\_PI / 180.0;}
\DoxyCodeLine{469 \}}
\DoxyCodeLine{470 \textcolor{keyword}{inline} \textcolor{keywordtype}{float} rad2deg(\textcolor{keywordtype}{float} rad) \{}
\DoxyCodeLine{471     \textcolor{keywordflow}{return} rad * 180.0 / M\_PI;}
\DoxyCodeLine{472 \}}
\DoxyCodeLine{473 \textcolor{keyword}{inline} \textcolor{keywordtype}{float} sign(\textcolor{keywordtype}{float} value) \{}
\DoxyCodeLine{474     \textcolor{keywordflow}{return} value < 0 ? -\/1.0 : 1.0;}
\DoxyCodeLine{475 \}}
\DoxyCodeLine{476 \textcolor{keyword}{inline} \textcolor{keywordtype}{float} clamp(\textcolor{keywordtype}{float} value, \textcolor{keywordtype}{float} min, \textcolor{keywordtype}{float} max) \{}
\DoxyCodeLine{477   \textcolor{keywordflow}{if} (min > max) \{}
\DoxyCodeLine{478     assert(0);}
\DoxyCodeLine{479     \textcolor{keywordflow}{return} value;}
\DoxyCodeLine{480   \}}
\DoxyCodeLine{481   \textcolor{keywordflow}{return} value < min ? min : value > max ? max : value;}
\DoxyCodeLine{482 \}}
\DoxyCodeLine{483 \textcolor{keyword}{inline} \textcolor{keywordtype}{float} round(\textcolor{keywordtype}{float} val, \textcolor{keywordtype}{int} dig) \{}
\DoxyCodeLine{484     \textcolor{keywordtype}{float} vv, mult, rnd;}
\DoxyCodeLine{485     mult = 1.0;}
\DoxyCodeLine{486     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < dig; ++i) mult=mult*10;}
\DoxyCodeLine{487     vv = mult*val;}
\DoxyCodeLine{488     \textcolor{comment}{//}}
\DoxyCodeLine{489     \textcolor{keywordflow}{if} (vv < 0) \{}
\DoxyCodeLine{490         rnd = ceil(vv -\/ 0.5);}
\DoxyCodeLine{491     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{492         rnd = floor(vv + 0.5);}
\DoxyCodeLine{493     \}}
\DoxyCodeLine{494     \textcolor{comment}{//}}
\DoxyCodeLine{495     \textcolor{keywordflow}{return} (rnd/mult);}
\DoxyCodeLine{496 \}}
\DoxyCodeLine{499 \}  \textcolor{comment}{// namespace std}}
\DoxyCodeLine{502 \textcolor{comment}{}\textcolor{preprocessor}{\#endif  }\textcolor{comment}{// \_STORAGE\_NUMERIC\_HPP\_}}

\end{DoxyCode}
